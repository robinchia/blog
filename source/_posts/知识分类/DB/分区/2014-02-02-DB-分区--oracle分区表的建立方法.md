---
layout: post
title: "oracle 分区表的建立方法"
categories: DB
tags: 
 - DB
 - 分区
--- 

# oracle 分区表的建立方法

![]()  ![]()登陆论坛 [](http://www.xxlinux.com/bbs/register.php) | [论坛注册](http://www.xxlinux.com/bbs/register.php)| [加入收藏](http://www.xxlinux.com/linux/article/development/database/20070410/8140.html#ecms) | [设为首页](http://www.xxlinux.com/linux/article/development/database/20070410/8140.html#ecms)| [RSS![]()](http://www.xxlinux.com/linux/e/web/?type=rss2&classid=11) [![]()](http://www.xxlinux.com/linux/) * [首页](http://www.xxlinux.com/linux/)
* [Linux频道](http://www.xxlinux.com/linux/article/)
* [软件下载](http://www.xxlinux.com/linux/download/)
* [开发语言](http://www.xxlinux.com/linux/dev/)
* [嵌入式频道](http://www.xxlinux.com/linux/embed/)
* [开源论坛](http://bbs.xxlinux.com/) | [数据库开发](http://www.xxlinux.com/linux/article/development/database/) | [WEB开发](http://www.xxlinux.com/linux/article/development/web/) | [软件开发](http://www.xxlinux.com/linux/article/development/soft/) | [嵌入应用](http://www.xxlinux.com/linux/article/development/embed/) | [内核研究](http://www.xxlinux.com/linux/article/development/kernel/) | [SHELL](http://www.xxlinux.com/linux/article/development/shell/) | [![Google]()](http://www.google.com/) 输入您的搜索字词  提交搜索表单 您当前的位置：[首页](http://www.xxlinux.com/linux/) > [Linux频道](http://www.xxlinux.com/linux/article/) > [Linux开发区](http://www.xxlinux.com/linux/article/development/) > [数据库开发](http://www.xxlinux.com/linux/article/development/database/) # oracle 分区表的建立方法 时间：2007-04-10 11:23:03  来源：[Linux联盟收集整理](http://www.xxlinux.com/)  作者： Oracle提供了分区技术以支持VLDB(Very Large DataBase)。分区表通过对分区列的判断，把分区列不同的记录，放到不同的分区中。分区完全对应用透明。

Oracle的分区表可以包括多个分区，每个分区都是一个独立的段（SEGMENT），可以存放到不同的表空间中。查询时可以通过查询表来访问各个分区中的数据，也可以通过在查询时直接指定分区的方法来进行查询。

分区提供以下优点： 

由于将数据分散到各个分区中，减少了数据损坏的可能性； 

可以对单独的分区进行备份和恢复； 

可以将分区映射到不同的物理磁盘上，来分散IO；

提高可管理性、可用性和性能。 

Oracle提供了以下几种分区类型：

范围分区（range）；

哈希分区（hash）；

列表分区（list）；

范围－哈希复合分区（range-hash）；

范围－列表复合分区（range-list）。

Oracle的普通表没有办法通过修改属性的方式直接转化为分区表，必须通过重建的方式进行转变，下面介绍三种效率比较高的方法，并说明它们各自的特点。

方法一：利用原表重建分区表。 

步骤： 

SQL> CREATE TABLE T (ID NUMBER PRIMARY KEY, TIME DATE);

表已创建。 

SQL> INSERT INTO T SELECT ROWNUM, CREATED FROM DBA_OBJECTS;

已创建6264行。

SQL> COMMIT;

提交完成。

SQL> CREATE TABLE T_NEW (ID, TIME) PARTITION BY RANGE (TIME)
  2  (PARTITION P1 VALUES LESS THAN (TO_DATE('2004-7-1', 'YYYY-MM-DD')),
  3  PARTITION P2 VALUES LESS THAN (TO_DATE('2005-1-1', 'YYYY-MM-DD')),
  4  PARTITION P3 VALUES LESS THAN (TO_DATE('2005-7-1', 'YYYY-MM-DD')),
  5  PARTITION P4 VALUES LESS THAN (MAXVALUE))
  6  AS SELECT ID, TIME FROM T;

表已创建。 

SQL> RENAME T TO T_OLD;

表已重命名。 

SQL> RENAME T_NEW TO T;

表已重命名。 

SQL> SELECT COUNT(*) FROM T;

  COUNT(*)
----------
      6264

SQL> SELECT COUNT(*) FROM T PARTITION (P1);

  COUNT(*)
----------
         0

SQL> SELECT COUNT(*) FROM T PARTITION (P2);

  COUNT(*)
----------
      6246

SQL> SELECT COUNT(*) FROM T PARTITION (P3);

  COUNT(*)
----------
        18

优点：方法简单易用，由于采用DDL语句，不会产生UNDO，且只产生少量REDO，效率相对较高，而且建表完成后数据已经在分布到各个分区中了。

不足：对于数据的一致性方面还需要额外的考虑。由于几乎没有办法通过手工锁定T表的方式保证一致性，在执行CREATE TABLE语句和RENAME T_NEW TO T语句直接的修改可能会丢失，如果要保证一致性，需要在执行完语句后对数据进行检查，而这个代价是比较大的。另外在执行两个RENAME语句之间执行的对T的访问会失败。

适用于修改不频繁的表，在闲时进行操作，表的数据量不宜太大。 

方法二：使用交换分区的方法。 

步骤： 

SQL> CREATE TABLE T (ID NUMBER PRIMARY KEY, TIME DATE);

表已创建。 

SQL> INSERT INTO T SELECT ROWNUM, CREATED FROM DBA_OBJECTS;

已创建6264行。

SQL> COMMIT;

提交完成。 

SQL> CREATE TABLE T_NEW (ID NUMBER PRIMARY KEY, TIME DATE) PARTITION BY RANGE (TIME)
  2  (PARTITION P1 VALUES LESS THAN (TO_DATE('2005-7-1', 'YYYY-MM-DD')),
  3  PARTITION P2 VALUES LESS THAN (MAXVALUE));

表已创建。 

SQL> ALTER TABLE T_NEW EXCHANGE PARTITION P1 WITH TABLE T;

表已更改。 

SQL> RENAME T TO T_OLD;

表已重命名。 

SQL> RENAME T_NEW TO T;

表已重命名。 

SQL> SELECT COUNT(*) FROM T;

  COUNT(*)
----------
      6264

优点：只是对数据字典中分区和表的定义进行了修改，没有数据的修改或复制，效率最高。如果对数据在分区中的分布没有进一步要求的话，实现比较简单。在执行完RENAME操作后，可以检查T_OLD中是否存在数据，如果存在的话，直接将这些数据插入到T中，可以保证对T插入的操作不会丢失。

不足：仍然存在一致性问题，交换分区之后RENAME T_NEW TO T之前，查询、更新和删除会出现错误或访问不到数据。如果要求数据分布到多个分区中，则需要进行分区的SPLIT操作，会增加操作的复杂度，效率也会降低。

适用于包含大数据量的表转到分区表中的一个分区的操作。应尽量在闲时进行操作。 

方法三：Oracle9i以上版本，利用在线重定义功能

步骤： 

SQL> CREATE TABLE T (ID NUMBER PRIMARY KEY, TIME DATE);

表已创建。 

SQL> INSERT INTO T SELECT ROWNUM, CREATED FROM DBA_OBJECTS;

已创建6264行。

SQL> COMMIT;

提交完成。 

SQL> EXEC DBMS_REDEFINITION.CAN_REDEF_TABLE(USER, 'T', DBMS_REDEFINITION.CONS_USE_PK);

PL/SQL 过程已成功完成。

SQL> CREATE TABLE T_NEW (ID NUMBER PRIMARY KEY, TIME DATE) PARTITION BY RANGE (TIME)
  2  (PARTITION P1 VALUES LESS THAN (TO_DATE('2004-7-1', 'YYYY-MM-DD')),
  3  PARTITION P2 VALUES LESS THAN (TO_DATE('2005-1-1', 'YYYY-MM-DD')),
  4  PARTITION P3 VALUES LESS THAN (TO_DATE('2005-7-1', 'YYYY-MM-DD')),
  5  PARTITION P4 VALUES LESS THAN (MAXVALUE));

表已创建。 

SQL> EXEC DBMS_REDEFINITION.START_REDEF_TABLE(USER, 'T', 'T_NEW', -
> 'ID ID, TIME TIME', DBMS_REDEFINITION.CONS_USE_PK);

PL/SQL 过程已成功完成。

SQL> EXEC DBMS_REDEFINITION.FINISH_REDEF_TABLE('YANGTK', 'T', 'T_NEW');

PL/SQL 过程已成功完成。

SQL> SELECT COUNT(*) FROM T;

  COUNT(*)
----------
      6264

SQL> SELECT COUNT(*) FROM T PARTITION (P2);

  COUNT(*)
----------
      6246

SQL> SELECT COUNT(*) FROM T PARTITION (P3);

  COUNT(*)
----------
        18

优点：保证数据的一致性，在大部分时间内，表T都可以正常进行DML操作。只在切换的瞬间锁表，具有很高的可用性。这种方法具有很强的灵活性，对各种不同的需要都能满足。而且，可以在切换前进行相应的授权并建立各种约束，可以做到切换完成后不再需要任何额外的管理操作。

不足：实现上比上面两种略显复杂。 

适用于各种情况。 

这里只给出了在线重定义表的一个最简单的例子，详细的描述和例子可以参考下面两篇文章。 

Oracle的在线重定义表功能：[http://blog.itpub.net/post/468/12855](http://blog.itpub.net/post/468/12855)

Oracle的在线重定义表功能（二）：[http://blog.itpub.net/post/468/12962](http://blog.itpub.net/post/468/12962)

索引也可以进行分区，分区索引有两种类型：global和local。对于local索引，每一个表分区对应一个索引分区，当表的分区发生变化时，索引的维护由Oracle自动进行。对于global索引，可以选择是否分区，而且索引的分区可以不与表分区相对应。当对分区进行维护操作时，通常会导致全局索引的INVALDED，必须在执行完操作后REBUILD。Oracle9i提供了UPDATE GLOBAL INDEXES语句，可以使在进行分区维护的同时重建全局索引。

全局索引可以包含多个分区的值 局部索引比全局索引容易管理,而全局索引比较快
注意:不能为散列分区 或者 子分区创建全局索引

Oracle的分区功能十分强大。不过用起来发现有两点不大方便：

第一是已经存在的表没有方法可以直接转化为分区表。不过Oracle提供了在线重定义表的功能，可以通过这种方式来完成普通表到分区表的转化。可以参考这个例子：[http://blog.itpub.net/post/468/13091](http://blog.itpub.net/post/468/13091)

第二点是如果采用了local分区索引，那么在增加表分区的时候，索引分区的表空间是不可控制的。如果希望将表和索引的分区分开到不同的表空间且不同索引分区也分散到不同的表空间中，那么只能在增加分区后，对新增的分区索引单独rebuild。

Oracle最大允许存在多少个分区呢?

我们可以从Oracle的[Concepts手册](http://tahiti.oracle.com/)上找到这个信息，对于Oracle9iR2:
Tables can be partitioned into up to **64,000** separate partitions.

对于Oracle10gR2，Oracle增强了分区特性：

Tables can be partitioned into up to **1024K-1** separate partitions.

关于何时应该进行分区,Oracle有如下建议:

■ Tables greater than 2GB should always be considered for partitioning.
■ Tables containing historical data, in which new data is added into the newest partition. A typical example is a historical table where only the current month's data is updatable and the other 11 months are read only. **** [来顶一下]() **[![近回首页]()](http://www.xxlinux.com/linux/)** [返回首页](http://www.xxlinux.com/linux/)   **发表评论** [共有  条评论](http://www.xxlinux.com/linux/e/pl?classid=11&id=8140) 用户名: 密码: 验证码:  ![]() 匿名发表[]() **相关文章** * [Oracle数据库应用程序性能优化探](http://www.xxlinux.com/linux/article/development/database/20070410/8139.html "Oracle数据库应用程序性能优化探究")
* [Oracle 9i中自动撤销管理的优点分](http://www.xxlinux.com/linux/article/development/database/20070410/8138.html "Oracle 9i中自动撤销管理的优点分析")
* [Oracle 9i数据库中动态重配置深入](http://www.xxlinux.com/linux/article/development/database/20070410/8137.html "Oracle 9i数据库中动态重配置深入分析")
* [Oracle数据库编写PL/SQL代码经验](http://www.xxlinux.com/linux/article/development/database/20070410/8136.html "Oracle数据库编写PL/SQL代码经验谈")
* [教你Oracle的数据缓冲区是如何工](http://www.xxlinux.com/linux/article/development/database/20070410/8135.html "教你Oracle的数据缓冲区是如何工作")
* [redhat 9 上安装oracle](http://www.xxlinux.com/linux/article/development/database/20070409/8127.html "redhat 9 上安装oracle")
* [关于Oracle 9i数据库密码重用规则](http://www.xxlinux.com/linux/article/development/database/20070409/8121.html "关于Oracle 9i数据库密码重用规则分析")
* [Oracle的恢复管理器及DBMS_JOB包](http://www.xxlinux.com/linux/article/development/database/20070409/8120.html "Oracle的恢复管理器及DBMS_JOB包分析")
* [利用Oracle执行计划机制提高查询](http://www.xxlinux.com/linux/article/development/database/20070409/8119.html "利用Oracle执行计划机制提高查询性能")
* [Unix环境下Oracle数据库优化心得](http://www.xxlinux.com/linux/article/development/database/20070406/8110.html "Unix环境下Oracle数据库优化心得介绍") **栏目更新**  **栏目热门** **站内搜索：**     Linux频道 下载频道 图库 商品 嵌入式频道 []() [高级搜索](http://www.xxlinux.com/linux/search/) [网站首页](http://www.xxlinux.com/linux/) | [栏目导航](http://www.xxlinux.com/linux/article/news/dt/2009-01-06/14778.html) | [服务条款](http://www.xxlinux.com/linux/article/development/database/20070410/8140.html#) | [广告服务](http://www.xxlinux.com/linux/article/development/database/20070410/8140.html#) | [联系我们](http://www.xxlinux.com/linux/article/development/database/20070410/8140.html#) | [网站大全](http://www.xxlinux.com/linux/article/news/dt/2006-05-31/1076.html) | [免责声明](http://www.xxlinux.com/linux/article/development/database/20070410/8140.html#) | [返回顶部](http://www.xxlinux.com/linux/article/development/database/20070410/8140.html#) Copyright © 2007-2008 xxlinux.com, All rights reserved. Powered by linux联盟 [京ICP备05012402号](http://www.miibeian.gov.cn/)
 
