---
layout: post
title: "算法复杂度汇总（图）!"
categories: Java&J2EE
tags: 
 - Java&J2EE
 - 算法&数组&优化
 - 算法
--- 

# 算法复杂度汇总（图）!

# Know Thy Complexities!

Hi there! This webpage covers the space and time Big-O complexities of common algorithms used in Computer Science. When preparing for technical interviews in the past, I found myself spending hours crawling the internet putting together the best, average, and worst case complexities for search and sorting algorithms so that I wouldn't be stumped when asked about them. Over the last few years, I've interviewed at several Silicon Valley startups, and also some bigger companies, like Yahoo, eBay, LinkedIn, and Google, and each time that I prepared for an interview, I thought to msyelf "Why oh why hasn't someone created a nice Big-O cheat sheet?". So, to save all of you fine folks a ton of time, I went ahead and created one. Enjoy!
Good
 
Fair
 
Poor

## Searching

Algorithm Data Structure Time Complexity Space Complexity Average Worst Worst [Depth First Search (DFS)](http://en.wikipedia.org/wiki/Depth-first_search) Graph of |V| vertices and |E| edges 
-
 
O(|E| + |V|)
 
O(|V|) [Breadth First Search (BFS)](http://en.wikipedia.org/wiki/Breadth-first_search) Graph of |V| vertices and |E| edges 
-
 
O(|E| + |V|)
 
O(|V|) [Binary search](http://en.wikipedia.org/wiki/Binary_search_algorithm) Sorted array of n elements 
O(log(n))
 
O(log(n))
 
O(1) [Linear (Brute Force)](http://en.wikipedia.org/wiki/Brute-force_search) Array 
O(n)
 
O(n)
 
O(1) [Shortest path by Dijkstra,
using a Min-heap as priority queue](http://en.wikipedia.org/wiki/Dijkstra's_algorithm) Graph with |V| vertices and |E| edges 
O((|V| + |E|) log |V|)
 
O((|V| + |E|) log |V|)
 
O(|V|) [Shortest path by Dijkstra,
using an unsorted array as priority queue](http://en.wikipedia.org/wiki/Dijkstra's_algorithm) Graph with |V| vertices and |E| edges 
O(|V|^2)
 
O(|V|^2)
 
O(|V|) [Shortest path by Bellman-Ford](http://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm) Graph with |V| vertices and |E| edges 
O(|V||E|)
 
O(|V||E|)
 
O(|V|)

## Sorting

Algorithm Data Structure Time Complexity Worst Case Auxiliary Space Complexity Best Average Worst Worst [Quicksort](http://en.wikipedia.org/wiki/Quicksort) Array 
O(n log(n))
 
O(n log(n))
 
O(n^2)
 
O(log(n)) [Mergesort](http://en.wikipedia.org/wiki/Merge_sort) Array 
O(n log(n))
 
O(n log(n))
 
O(n log(n))
 
O(n) [Heapsort](http://en.wikipedia.org/wiki/Heapsort) Array 
O(n log(n))
 
O(n log(n))
 
O(n log(n))
 
O(1) [Bubble Sort](http://en.wikipedia.org/wiki/Bubble_sort) Array 
O(n)
 
O(n^2)
 
O(n^2)
 
O(1) [Insertion Sort](http://en.wikipedia.org/wiki/Insertion_sort) Array 
O(n)
 
O(n^2)
 
O(n^2)
 
O(1) [Select Sort](http://en.wikipedia.org/wiki/Selection_sort) Array 
O(n^2)
 
O(n^2)
 
O(n^2)
 
O(1) [Bucket Sort](http://en.wikipedia.org/wiki/Bucket_sort) Array 
O(n+k)
 
O(n+k)
 
O(n^2)
 
O(nk) [Radix Sort](http://en.wikipedia.org/wiki/Radix_sort) Array 
O(nk)
 
O(nk)
 
O(nk)
 
O(n+k)

## Data Structures

Data Structure Time Complexity Space Complexity Average Worst Worst Indexing Search Insertion Deletion Indexing Search Insertion Deletion [Basic Array](http://en.wikipedia.org/wiki/Array_data_structure) 
O(1)
 
O(n)
 
-
 
-
 
O(1)
 
O(n)
 
-
 
-
 
O(n) [Dynamic Array](http://en.wikipedia.org/wiki/Dynamic_array) 
O(1)
 
O(n)
 
O(n)
 
-
 
O(1)
 
O(n)
 
O(n)
 
-
 
O(n) [Singly-Linked List](http://en.wikipedia.org/wiki/Singly_linked_list#Singly_linked_lists) 
O(n)
 
O(n)
 
O(1)
 
O(1)
 
O(n)
 
O(n)
 
O(1)
 
O(1)
 
O(n) [Doubly-Linked List](http://en.wikipedia.org/wiki/Doubly_linked_list) 
O(n)
 
O(n)
 
O(1)
 
O(1)
 
O(n)
 
O(n)
 
O(1)
 
O(1)
 
O(n) [Skip List](http://en.wikipedia.org/wiki/Skip_list) 
O(n)
 
O(log(n))
 
O(log(n))
 
O(log(n))
 
O(n)
 
O(n)
 
O(n)
 
O(n)
 
O(n log(n)) [Hash Table](http://en.wikipedia.org/wiki/Hash_table) 
-
 
O(1)
 
O(1)
 
O(1)
 
-
 
O(n)
 
O(n)
 
O(n)
 
O(n) [Binary Search Tree](http://en.wikipedia.org/wiki/Binary_search_tree) 
-
 
O(log(n))
 
O(log(n))
 
O(log(n))
 
-
 
O(n)
 
O(n)
 
O(n)
 
O(n) [B-Tree](http://en.wikipedia.org/wiki/B_tree) 
-
 
O(log(n))
 
O(log(n))
 
O(log(n))
 
-
 
O(log(n))
 
O(log(n))
 
O(log(n))
 
O(n) [Red-Black Tree](http://en.wikipedia.org/wiki/Red-black_tree) 
-
 
O(log(n))
 
O(log(n))
 
O(log(n))
 
-
 
O(log(n))
 
O(log(n))
 
O(log(n))
 
O(n) [AVL Tree](http://en.wikipedia.org/wiki/AVL_tree) 
-
 
O(log(n))
 
O(log(n))
 
O(log(n))
 
-
 
O(log(n))
 
O(log(n))
 
O(log(n))
 
O(n)

## Heaps

Heaps Time Complexity Heapify Find Max Extract Max Increase Key Insert Delete Merge [Linked List (sorted)](http://en.wikipedia.org/wiki/Linked_list) 
-
 
O(1)
 
O(1)
 
O(n)
 
O(n)
 
O(1)
 
O(m+n) [Linked List (unsorted)](http://en.wikipedia.org/wiki/Linked_list) 
-
 
O(n)
 
O(n)
 
O(1)
 
O(1)
 
O(1)
 
O(1) [Binary Heap](http://en.wikipedia.org/wiki/Binary_heap) 
O(log(n))
 
O(1)
 
O(log(n))
 
O(log(n))
 
O(log(n))
 
O(log(n))
 
O(m+n) [Binomial Heap](http://en.wikipedia.org/wiki/Binomial_heap) 
-
 
O(log(n))
 
O(log(n))
 
O(log(n))
 
O(log(n))
 
O(log(n))
 
O(log(n)) [Fibonacci Heap](http://en.wikipedia.org/wiki/Fibonacci_heap) 
-
 
O(1)
 
O(log(n))*
 
O(1)*
 
O(1)
 
O(log(n))*
 
O(1)

## Graphs

Node / Edge Management Storage Add Vertex Add Edge Remove Vertex Remove Edge Query [Adjacency list](http://en.wikipedia.org/wiki/Adjacency_list) 
O(|V|+|E|)
 
O(1)
 
O(1)
 
O(|V| + |E|)
 
O(|E|)
 
O(|V|) [Incidence list](http://en.wikipedia.org/wiki/Incidence_list) 
O(|V|+|E|)
 
O(1)
 
O(1)
 
O(|E|)
 
O(|E|)
 
O(|E|) [Adjacency matrix](http://en.wikipedia.org/wiki/Adjacency_matrix) 
O(|V|^2)
 
O(|V|^2)
 
O(1)
 
O(|V|^2)
 
O(1)
 
O(1) [Incidence matrix](http://en.wikipedia.org/wiki/Incidence_matrix) 
O(|V| |E|)
 
O(|V| |E|)
 
O(|V| |E|)
 
O(|V| |E|)
 
O(|V| |E|)
 
O(|E|)

## Notation for asymptotic growth

letter bound growth (theta) Θ upper and lower, tight[[1]](http://bigocheatsheet.com/#footnote-1) equal[[2]](http://bigocheatsheet.com/#footnote-1) (big-oh) O upper, tightness unknown less than or equal[[3]](http://bigocheatsheet.com/#footnote-1) (small-oh) o upper, not tight less than (big omega) Ω lower, tightness unknown greater than or equal (small omega) ω lower, not tight greater than

[1] Big O is the upper bound, while Omega is the lower bound. Theta requires both Big O and Omega, so that's why it's referred to as a tight bound (it must be both the upper and lower bound). For example, an algorithm taking Omega(n log n) takes at least n log n time but has no upper limit. An algorithm taking Theta(n log n) is far preferential since it takes AT LEAST n log n (Omega n log n) and NO MORE THAN n log n (Big O n log n).[SO](http://stackoverflow.com/a/464081/412916)

[2] f(x)=Θ(g(n)) means f (the running time of the algorithm) grows exactly like g when n (input size) gets larger. In other words, the growth rate of f(x) is asymptotically proportional to g(n).

[3] Same thing. Here the growth rate is no faster than g(n). big-oh is the most useful because represents the worst-case behavior.
In short, if algorithm is __ then its performance is __ algorithm performance o(n) < n O(n) ≤ n Θ(n) = n Ω(n) ≥ n ω(n) > n

## Big-O Complexity Chart

![Big O Complexity Graph]( "Big O Complexity Graph")

## Contribute

[Edit these tables!](https://github.com/ericdrowell/BigOCheatSheet/blob/master/Tables.html)

Authors:

1. [Eric Rowell](https://github.com/ericdrowell)
1. [Quentin Pleple](https://github.com/qpleple)
1. [Nick Dizazzo](https://github.com/ndizazzo)
1. [Michael Abed](https://github.com/vault)
1. [Adam Forsyth](https://github.com/agfor)
1. [Jay Engineer](https://github.com/jay754)
1. [Josh Davis](https://github.com/jdavis)
1. [makosblade](https://github.com/makosblade)
1. [Alejandro Ramirez](https://github.com/j4n0)
1. [Joel Friedly](https://github.com/jfriedly)
1. [Eric Lefevre-Ardant](https://github.com/elefevre)
1. [Thomas Dybdahl Ahle](https://github.com/thomasahle)
