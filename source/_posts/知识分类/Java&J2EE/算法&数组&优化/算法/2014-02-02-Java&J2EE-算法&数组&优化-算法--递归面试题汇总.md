---
layout: post
title: "递归面试题汇总"
categories: Java&J2EE
tags: 
 - Java&J2EE
 - 算法&数组&优化
 - 算法
--- 

# 递归面试题汇总

您还未登录！|[登录](https://passport.csdn.net/account/login)|[注册](https://passport.csdn.net/account/register)|[帮助](https://passport.csdn.net/help/faq)

* [首页](http://www.csdn.net/)
* [业界](http://news.csdn.net/)
* [移动](http://mobile.csdn.net/)
* [云计算](http://cloud.csdn.net/)
* [研发](http://sd.csdn.net/)
* [论坛](http://bbs.csdn.net/)
* [博客](http://blog.csdn.net/)
* [下载](http://download.csdn.net/)
* 
## [更多]()

# [石锅拌饭](http://blog.csdn.net/ssjhust123)

## 一介书生，读两三卷诗书，四体不勤，五谷不分，行六百里路途，乱七八糟到大学，久不思上进，十分颓废之人的胡言乱语

* [![]()目录视图](http://blog.csdn.net/ssjhust123?viewmode=contents)
* [![]()摘要视图](http://blog.csdn.net/ssjhust123?viewmode=list)
* [![]()订阅](http://blog.csdn.net/ssjhust123/rss/list)
[专访赵霏：应把握机会 HTML5游戏开发已臻成熟](http://www.csdn.net/article/2013-07-09/2816160)        [2013年7月微软MVP当选名单揭晓](http://blog.csdn.net/blogdevteam/article/details/9226601)      [CSDN博客频道自定义摘要、图片水印、热门标签等功能上线啦](http://blog.csdn.net/csdnproduct/article/details/9226265)      [CSDN博客第二期云计算最佳博主评选](http://blog.csdn.net/blogdevteam/article/details/9136613)      []()

### [递归面试题汇总]()

分类： [面试题系列](http://blog.csdn.net/ssjhust123/article/category/1112654) [数据结构与算法](http://blog.csdn.net/ssjhust123/article/category/1190606)  2012-08-27 21:30 707人阅读 [评论]()(0) [收藏]( "收藏") [举报]( "举报")
目录[(?)]( "系统根据文章中H1到H6标签自动生成文章目录")[[+]]( "展开")

1. []()
1. [一前言]()
1. [二递归算法初探]()
1. [三递归算法题]()

1. [汉诺塔问题]()
1. [求二叉树的深度]()
1. [判断二叉树是否平衡]()

1. []()

1. [排列算法]()
1. [组合算法]()

## []()

## []()一、前言

找工作面试时最喜欢问的是算法题，虽然我觉得有些取巧的算法题只是跟刷题量有关。但是为了找工作不得不加强算法，特别是基础算法，这是一个人基本功的体现。《算法导论》是不错的教材，不过大部头看起来确实需要发时间，到现在还只是大略看了一遍，很多推导过程没细心看下来，深以为憾，以后有时间还是要猛补。算法题中最能体现算法精髓的则非递归莫属了，我对递归一直总觉得是一知半解，为了加深自己的理解，决定把自己的一些想法记下来，方便更好的理清自己的思路，也恳请各路大牛指正。

## []()二、递归算法初探

本段内容素材来自《linux C一站式编程》，作者是宋劲松老师，说实话这是目前看到的国内关于linux C编程的最好的一本技术书籍，强烈推荐！

关于递归的一个简单例子是求整数阶乘，n!=n*(n-1)!，0!=1 。则可以写出如下的递归程序：

**[cpp]** [view plain]( "view plain")[copy]( "copy")[print]( "print")[?]( "?")

1. int factorial(int n)  
1. {  
1.     if (n == 0)  
1.         return 1;  
1.     else {  
1.         int recurse = factorial(n-1);  
1.         int result = n * recurse;  
1.         return result;  
1.     }  
1. }  
int factorial(int n) { if (n == 0) return 1; else { int recurse = factorial(n-1); int result = n * recurse; return result; } }

factorial
这个函数就是一个递归函数，它调用了它自己。**自己直接或间接调用自己的函数称为递归函数。**这里的

factorial
是直接调用自己，有些时候函数A调用函数B，函数B又调用函数A，也就是函数A间接调用自己，这也是递归函数。如果觉得迷惑，**可以把****
factorial(n-1)
****这一步看成是在调用另一个函数**－－另一个有着相同函数名和相同代码的函数，调用它就是跳到它的代码里执行，然后再返回

factorial(n-1)
这个调用的下一步继续执行。

为了证明递归算法的正确性，我们可以一步步跟进去看执行结果。记得刚学递归算法的时候，老是有丈二和尚摸不着头脑的感觉，那时候总是想着把递归一步步跟进去看执行结果。递归层次少还算好办，但是层次一多，头就大了，完全不知道自己跟到了递归的哪一层。比如求阶乘，如果只是factorial(3)跟进去问题不大，但是若是factorial(100)那就麻烦了。

事实上，我们并不是每个函数都需要跟进去看执行结果的，比如我们在自己的函数中调用printf函数时，并没有钻进去看它是怎么打印的，因为我们**相信**它能完成打印工作。我们在写factorial函数时有如下代码：

**[cpp]** [view plain]( "view plain")[copy]( "copy")[print]( "print")[?]( "?")

1. ...  
1. int recurse = factorial(n-1);  
1. int result = n * recurse;  
1. ...  
... int recurse = factorial(n-1); int result = n * recurse; ...

这时，如果我们相信factorial是正确的，那么传递参数为n-1它就会返回(n-1)!，那么result=n*(n-1)!=n!，从而这就是factorial(n)的结果。

当然这有点奇怪：我们还没写完

factorial
这个函数，凭什么要相信

factorial(n-1)
是正确的？可Leap of Faith本身就是Leap（跳跃）的，不是吗？**如果你相信你正在写的递归函数是正确的，并调用它，然后在此基础上写完这个递归函数，那么它就会是正确的，从而值得你相信它正确。**

这么说好像有点儿玄，我们从数学上严格证明一下

factorial
函数的正确性。刚才说了，

factorial(n)
的正确性依赖于

factorial(n-1)
的正确性，只要后者正确，在后者的结果上乘个

n
返回这一步显然也没有疑问，那么我们的函数实现就是正确的。因此要证明

factorial(n)
的正确性就是要证明

factorial(n-1)
的正确性，同理，要证明

factorial(n-1)
的正确性就是要证明

factorial(n-2)
的正确性，依此类推下去，最后是：要证明

factorial(1)
的正确性就是要证明

factorial(0)
的正确性。而

factorial(0)
的正确性不依赖于别的函数调用，它就是程序中的一个小的分支

return 1;
这个1是我们根据阶乘的定义写的，肯定是正确的，因此

factorial(1)
的实现是正确的，因此

factorial(2)
也正确，依此类推，最后

factorial(n)
也是正确的。其实这就是在中学时学的数学归纳法（Mathematical Induction），用数学归纳法来证明只需要证明两点：Base Case正确，递推关系正确。**写递归函数时一定要记得写Base Case**，否则即使递推关系正确，整个函数也不正确。如果

factorial
函数漏掉了Base Case，那么会导致无限循环。

## []()三、递归算法题

从上一节的一个关于求阶乘的简单例子的论述，我们可以了解到递归算法的精髓：**要从功能上理解函数，同时你要相信你正在写的函数是正确的，在此基础上调用它，那么它就是正确的。**下面就从几个常见的算法题来看看如何理解递归，这是我的一些理解，欢迎大家提出更好的方法。

### []()1）汉诺塔问题

汉诺塔问题是个常见问题，就是说有n个大小不等的盘子放在一个塔A上面，自底向上按照从小到大的顺序排列。要求将所有n个盘子搬到另一个塔C上面，可以借助一个塔B中转，但是要满足任何时刻大盘子不能放在小盘子上面。

基本思想分三步，先把上面的N-1个盘子经C移到B，然后将最底下的盘子移到C，再讲B上面的N-1个盘子经A移动到C。总的时间复杂度f(n)=2f(n-1)+1，所以f(n)=2^n-1。
**[cpp]** [view plain]( "view plain")[copy]( "copy")[print]( "print")[?]( "?")

1. void hano(char a, char b, char c, int n) {  
1.     if (n > 0) {  
1.         hano(a, c, b, n-1);  
1.         move(a, c);  
1.         hano(b, a, c, n-1);  
1.     }  
1. }  
1.   
1. void move(char a, char b)  
1. {  
1.     cout << a << "->" << b << endl;  
1. }  
void hano(char a, char b, char c, int n) { if (n > 0) { hano(a, c, b, n-1); move(a, c); hano(b, a, c, n-1); } } void move(char a, char b) { cout << a << "->" << b << endl; }

 

### []()2）求二叉树的深度

这里的深度指的是二叉树从根结点到叶结点最大的高度，比如只有一个结点，则深度为1，如果有N层，则高度为N。

**[cpp]** [view plain]( "view plain")[copy]( "copy")[print]( "print")[?]( "?")

1. int depth(struct node* root)    
1. {    
1.     if (root == NULL)    
1.         return 0;    
1.     else {    
1.         int lDepth = depth(root->left);  //获取左子树深度    
1.         int rDepth = depth(root->right); //获取右子树深度    
1.         return lDepth>rDepth? lDepth+1: rDepth+1; //取较大值+1即为二叉树深度    
1.     }    
1. }    
int depth(struct node* root) { if (root == NULL) return 0; else { int lDepth = depth(root->left); //获取左子树深度 int rDepth = depth(root->right); //获取右子树深度 return lDepth>rDepth? lDepth+1: rDepth+1; //取较大值+1即为二叉树深度 } }

那么如何从功能上理解depth函数呢？我们可以知道定义该函数的目的就是求二叉树深度，也就是说我们要是完成了函数depth，那么depth(root)就能正确返回以root为根结点的二叉树的深度。**因此我们的代码中depth(root->left)返回左子树的深度，而depth(root->right)返回右子树的深度。尽管这个时候我们还没有写完depth函数，但是我们相信depth函数能够正确完成功能。**因此我们得到了lDepth和rDepth，而后通过比较返回较大值加1为二叉树的深度。如果不好理解，可以想象在depth中调用的函数depth(root->left)为另外一个同样名字完成相同功能的函数，这样就好理解了。

注意Base Case，这里就是当root==NULL时，则深度为0，函数返回0。

### []()3）判断二叉树是否平衡

一颗平衡的二叉树是指其任意结点的左右子树深度之差不大于1。判断一棵二叉树是否是平衡的，可以使用递归算法来实现。

**[cpp]** [view plain]( "view plain")[copy]( "copy")[print]( "print")[?]( "?")

1. bool is_balanced(BinaryTreeNode* pRoot)  
1. {  
1.     if(pRoot == NULL) //基本情况，为空的话，返回true  
1.         return true;  
1.    
1.     int left = depth(pRoot->m_pLeft);  
1.     int right = depth(pRoot->m_pRight);  
1.     int diff = left - right; //计算左右子树深度之差  
1.     if(diff > 1 || diff < -1) //如果深度之差大于1返回false  
1.         return false;  
1.    
1.     return is_balanced(pRoot->m_pLeft) && is_balanced(pRoot->m_pRight); //递归判断左右子树，注意是&&，即左右子树都必须是平衡的这棵二叉树才是平衡的  
1. }  
bool is_balanced(BinaryTreeNode* pRoot) { if(pRoot == NULL) //基本情况，为空的话，返回true return true; int left = depth(pRoot->m_pLeft); int right = depth(pRoot->m_pRight); int diff = left - right; //计算左右子树深度之差 if(diff > 1 || diff < -1) //如果深度之差大于1返回false return false; return is_balanced(pRoot->m_pLeft) && is_balanced(pRoot->m_pRight); //递归判断左右子树，注意是&&，即左右子树都必须是平衡的这棵二叉树才是平衡的 }

## []()

**该函数的功能定义是二叉树pRoot是平衡二叉树，即它所有结点的左右子树深度之差不大于1。首先判断根结点是否满足条件，如果不满足，则直接返回false。如果满足，则需要判断左子树和右子树是否都是平衡二叉树，若都是则返回true，否则false。**

上面代码性能不高，会重复遍历结点，一个改进的算法是采用后序遍历的方式遍历树的结点，在遍历到本结点前我们已经遍历完了它的左右子树，我们只需要在遍历的时候记录结点的深度，就可以一边遍历一边判断该结点是否是平衡的。代码如下：
**[cpp]** [view plain]( "view plain")[copy]( "copy")[print]( "print")[?]( "?")

1. bool is_balanced_2(BinaryTreeNode* pRoot, int* pDepth)  
1. {  
1.     if(pRoot == NULL)  
1.     {  
1.         *pDepth = 0;  
1.         return true;  
1.     }  
1.    
1.     int left, right;  
1.     if(is_balanced_2(pRoot->m_pLeft, &left) //左子树平衡  
1.         && is_balanced_2(pRoot->m_pRight, &right)) //右子树平衡  
1.     {  
1.         int diff = left - right;  
1.         if(diff <= 1 && diff >= -1)  
1.         {  
1.             *pDepth = 1 + (left > right ? left : right);  
1.             return true;  
1.         }  
1.     }  
1.    
1.     return false;  
1. }  
bool is_balanced_2(BinaryTreeNode* pRoot, int* pDepth) { if(pRoot == NULL) { *pDepth = 0; return true; } int left, right; if(is_balanced_2(pRoot->m_pLeft, &left) //左子树平衡 && is_balanced_2(pRoot->m_pRight, &right)) //右子树平衡 { int diff = left - right; if(diff <= 1 && diff >= -1) { *pDepth = 1 + (left > right ? left : right); return true; } } return false; }

**该函数功能定义是返回以pRoot为根的二叉树是否是平衡二叉树，同时把树的深度保存在pDepth指向的值中。**基本情况是树为NULL，则深度为0，返回true。否则只有左右子树都是平衡的情况下，深度分别存在变量left和right中，判断左右子树的深度之差是否不大于1，如果是则返回true，注意还要设置树的深度值。
调用的函数定义如下：

**[cpp]** [view plain]( "view plain")[copy]( "copy")[print]( "print")[?]( "?")

1. bool IsBalanced(BinaryTreeNode* pRoot)  
1. {  
1.     int depth = 0;  
1.     return is_balanced_2(pRoot, &depth);  
1. }  
bool IsBalanced(BinaryTreeNode* pRoot) { int depth = 0; return is_balanced_2(pRoot, &depth); }

### []()4）排列算法

排列算法也是递归的典范，记得当初第一次看时一层层跟代码，头都大了，现在从函数功能上来看确实好理解多了。先看代码：

**[cpp]** [view plain]( "view plain")[copy]( "copy")[print]( "print")[?]( "?")

1. void perm(int a[], int k, int N) { //k为起始位置，N为数组大小  
1.     if (k == N-1) {   
1.         output(a, N); //输出排列  
1.     } else {  
1.         for (int i=k; i<N; i++) {  
1.             swap(a, i, k); //交换  
1.             perm(a, k+1, N); //下一次排列  
1.             swap(a, i, k); //恢复原来的序列  
1.         }  
1.     }  
1. }  
void perm(int a[], int k, int N) { //k为起始位置，N为数组大小 if (k == N-1) { output(a, N); //输出排列 } else { for (int i=k; i<N; i++) { swap(a, i, k); //交换 perm(a, k+1, N); //下一次排列 swap(a, i, k); //恢复原来的序列 } } }**首先明确的是perm(a, k, N)函数的功能:输出数组a从位置k开始的所有排列，数组长度为N。这样我们在调用程序的时候，调用格式为perm(a, 0, N)，即输出数组从位置0开始的所有排列，也就是该数组的所有排列。**
基础条件是k==N-1，此时已经到达最后一个元素，一次排列已经完成，直接输出。否则，从位置k开始的每个元素都与位置k的值交换(包括自己与自己交换)，然后进行下一次排列，排列完成后记得恢复原来的序列。
假定数组a大小N=3，则程序调用perm(a, 0, 3)可以如下理解：

第一次交换0，0，并执行perm(a, 1, 3)，执行完再次交换0，0，数组此时又恢复成初始值。
第二次交换1，0（注意数组此时是初始值），并执行perm(a, 1, 3), 执行完再次交换1，0，数组此时又恢复成初始值。

第三次交换2，0，并执行perm(a, 1, 3)，执行完成后交换2，0，数组恢复成初始值。
也就是说，从功能上看，首先确定第0个位置，然后调用perm(a, 1, 3)输出从1开始的排列，这样就可以输出所有排列。而第0个位置可能的值为a[0], a[1],a[2]，这通过交换来保证第0个位置可能出现的值，记得每次交换后要恢复初始值。

如数组a={1,2,3}，则程序运行输出结果为：1 2 3 ，1 3 2 ，2 1 3 ，2 3 1 ，3 2 1 ，3 1 2 。即先输出以1为排列第一个值的排列，而后是2和3为第一个值的排列。

### []()5）组合算法
组合算法也可以用递归实现，只是它的原理跟0-1背包问题类似。即要么选要么不选，注意不能选重复的数。完整代码如下：

**[cpp]** [view plain]( "view plain")[copy]( "copy")[print]( "print")[?]( "?")

1. #include<iostream>  
1. using namespace std;  
1. #define N 3  //数组大小为3  
1. int select[N] = {0}; //选择数组，用于存储数组哪些数字被选中。  
1. /*输出数组中选中的数*/  
1. void output(int a[], int n)  
1. {  
1.     for (int i=0; i<n; i++) {  
1.         if (select[i])  
1.             cout << a[i] << " ";  
1.     }  
1.     cout << endl;  
1. }  
1. /*数组a从位置i开始选取k个数*/  
1. void combination(int a[], int i, int k)  
1. {  
1.     if (i > N) return; //位置超出数组范围直接返回，否则非法访问会出段错误  
1.     if (k == 0) {  //选取完了，输出选取的数字  
1.         output(a, N);  
1.     } else {  
1.         select[i] = 1;    
1.         combination(a, i+1, k-1); //第i个数字被选取，从后续i+1开始选取k-1个数  
1.         select[i] = 0;  
1.         combination(a, i+1, k); //第i个数字不选，则从后续i+1位置开始还要选取k个数  
1.     }  
1. }  
1.   
1. /*组合主函数，包括选取1到n个数字*/  
1. void combination_helper(int a[], int n) {  
1.     for (int k=1; k<=n; k++) {  
1.         combination(a, 0, k);  
1.     }  
1. }  
1.   
1. int main()  
1. {  
1.     int a[N] = {1, 2, 3};  
1.     combination_helper(a, N);  
1.     return 0;  
1. }  
#include<iostream> using namespace std; #define N 3 //数组大小为3 int select[N] = {0}; //选择数组，用于存储数组哪些数字被选中。 /*输出数组中选中的数*/ void output(int a[], int n) { for (int i=0; i<n; i++) { if (select[i]) cout << a[i] << " "; } cout << endl; } /*数组a从位置i开始选取k个数*/ void combination(int a[], int i, int k) { if (i > N) return; //位置超出数组范围直接返回，否则非法访问会出段错误 if (k == 0) { //选取完了，输出选取的数字 output(a, N); } else { select[i] = 1; combination(a, i+1, k-1); //第i个数字被选取，从后续i+1开始选取k-1个数 select[i] = 0; combination(a, i+1, k); //第i个数字不选，则从后续i+1位置开始还要选取k个数 } } /*组合主函数，包括选取1到n个数字*/ void combination_helper(int a[], int n) { for (int k=1; k<=n; k++) { combination(a, 0, k); } } int main() { int a[N] = {1, 2, 3}; combination_helper(a, N); return 0; }
分享到： []( "分享到新浪微博")[]( "分享到腾讯微博")

1. 上一篇：[数学之美—快排为什么那样快](http://blog.csdn.net/ssjhust123/article/details/7912490)
1. 下一篇：[组合算法面试题](http://blog.csdn.net/ssjhust123/article/details/7916358)
查看评论[]()

  暂无评论
您还没有登录,请[[登录]]()或[[注册]](http://passport.csdn.net/account/register?from=http%3A%2F%2Fblog.csdn.net%2Fssjhust123%2Farticle%2Fdetails%2F7913137)

* 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场[]()[]()
[![TOP]()]( "回到顶部")

个人资料

[![]( "访问我的空间")](http://my.csdn.net/ssjhust123)
[ssjhust123](http://my.csdn.net/ssjhust123)

[]( "[加关注]") []( "[发私信]")
[![]()](http://medal.blog.csdn.net/allmedal.aspx)

* 访问：57759次
* 积分：1427分
* 排名：第6777名

* 原创：79篇
* 转载：22篇
* 译文：3篇
* 评论：43条

文章搜索

[]()

文章分类

* [面试题系列](http://blog.csdn.net/ssjhust123/article/category/1112654)(59)
* [数据结构与算法](http://blog.csdn.net/ssjhust123/article/category/1190606)(40)
* [JAVA相关](http://blog.csdn.net/ssjhust123/article/category/1146662)(11)
* [Cassandra源码分析](http://blog.csdn.net/ssjhust123/article/category/1191115)(6)
* [Linux杂谈](http://blog.csdn.net/ssjhust123/article/category/1194764)(8)
* [链表](http://blog.csdn.net/ssjhust123/article/category/1215816)(8)
* [二叉树](http://blog.csdn.net/ssjhust123/article/category/1215817)(18)
* [字符串](http://blog.csdn.net/ssjhust123/article/category/1235411)(5)
* [自己动手系列](http://blog.csdn.net/ssjhust123/article/category/1237423)(4)
* [栈](http://blog.csdn.net/ssjhust123/article/category/1240352)(2)
* [数字之趣](http://blog.csdn.net/ssjhust123/article/category/1249446)(8)
* [排序](http://blog.csdn.net/ssjhust123/article/category/1254833)(4)
* [MYSQL杂谈](http://blog.csdn.net/ssjhust123/article/category/1266438)(3)
* [python相关](http://blog.csdn.net/ssjhust123/article/category/1418274)(5)
文章存档

* [2013年06月](http://blog.csdn.net/ssjhust123/article/month/2013/06)(2)
* [2013年05月](http://blog.csdn.net/ssjhust123/article/month/2013/05)(9)
* [2013年02月](http://blog.csdn.net/ssjhust123/article/month/2013/02)(1)
* [2012年12月](http://blog.csdn.net/ssjhust123/article/month/2012/12)(2)
* [2012年11月](http://blog.csdn.net/ssjhust123/article/month/2012/11)(1)
* [2012年10月](http://blog.csdn.net/ssjhust123/article/month/2012/10)(13)
* [2012年09月](http://blog.csdn.net/ssjhust123/article/month/2012/09)(13)
* [2012年08月](http://blog.csdn.net/ssjhust123/article/month/2012/08)(26)
* [2012年07月](http://blog.csdn.net/ssjhust123/article/month/2012/07)(31)
* [2012年05月](http://blog.csdn.net/ssjhust123/article/month/2012/05)(6)

展开

阅读排行

* [中缀表达式转换为后缀表达式](http://blog.csdn.net/ssjhust123/article/details/8001651 "中缀表达式转换为后缀表达式")(4679)
* [中序遍历和先序遍历/后序遍历构建二叉树](http://blog.csdn.net/ssjhust123/article/details/7783935 "中序遍历和先序遍历/后序遍历构建二叉树")(3637)
* [brk(), sbrk() 用法详解](http://blog.csdn.net/ssjhust123/article/details/7772153 "brk(), sbrk() 用法详解")(1968)
* [序列化/反序列化二叉树](http://blog.csdn.net/ssjhust123/article/details/7777665 "序列化/反序列化二叉树")(1891)
* [判定一棵二叉树是否是二叉搜索树](http://blog.csdn.net/ssjhust123/article/details/7771096 "判定一棵二叉树是否是二叉搜索树")(1869)
* [给定一个字符数组，存储有R、G、B字符，将所有字符按照RGB顺序排序](http://blog.csdn.net/ssjhust123/article/details/8040283 "给定一个字符数组，存储有R、G、B字符，将所有字符按照RGB顺序排序")(1806)
* [Cassandra中布隆过滤器详解](http://blog.csdn.net/ssjhust123/article/details/7766499 "Cassandra中布隆过滤器详解")(1698)
* [JAVA泛型编程全面总结](http://blog.csdn.net/ssjhust123/article/details/7566137 "JAVA泛型编程全面总结")(1320)
* [Debian6安装笔记](http://blog.csdn.net/ssjhust123/article/details/8224659 "Debian6安装笔记")(1143)
* [二叉树遍历之非递归算法](http://blog.csdn.net/ssjhust123/article/details/7773103 "二叉树遍历之非递归算法")(1121)
评论排行

* [中缀表达式转换为后缀表达式](http://blog.csdn.net/ssjhust123/article/details/8001651 "中缀表达式转换为后缀表达式")(8)
* [最长回文子串](http://blog.csdn.net/ssjhust123/article/details/7979541 "最长回文子串")(5)
* [JAVA类库分析之HashMap](http://blog.csdn.net/ssjhust123/article/details/7580510 "JAVA类库分析之HashMap")(5)
* [Debian6安装笔记](http://blog.csdn.net/ssjhust123/article/details/8224659 "Debian6安装笔记")(3)
* [JAVA泛型编程全面总结](http://blog.csdn.net/ssjhust123/article/details/7566137 "JAVA泛型编程全面总结")(2)
* [二叉树两结点的最低公共祖先结点(一)](http://blog.csdn.net/ssjhust123/article/details/7935537 "二叉树两结点的最低公共祖先结点(一)")(2)
* [二叉树遍历之非递归算法](http://blog.csdn.net/ssjhust123/article/details/7773103 "二叉树遍历之非递归算法")(2)
* [在数组中找出3个数使得它们和为0](http://blog.csdn.net/ssjhust123/article/details/7753785 "在数组中找出3个数使得它们和为0")(2)
* [已知一个函数rand7()能够生成1-7的随机数，请给出一个函数rand10()，该函数能够生成1-10的随机数。](http://blog.csdn.net/ssjhust123/article/details/7753012 "已知一个函数rand7()能够生成1-7的随机数，请给出一个函数rand10()，该函数能够生成1-10的随机数。")(2)
* [链表模拟加法问题](http://blog.csdn.net/ssjhust123/article/details/7978337 "链表模拟加法问题")(2)

最新评论

* [JAVA泛型编程全面总结](http://blog.csdn.net/ssjhust123/article/details/7566137#comments)

[ssjhust123](http://blog.csdn.net/ssjhust123): @zhuzi51job:哈哈，不客气，请多指正。
* [JAVA泛型编程全面总结](http://blog.csdn.net/ssjhust123/article/details/7566137#comments)

[zhuzi51job](http://blog.csdn.net/zhuzi51job): 写的很详细，谢谢你的分享。
* [最大连续子序列乘积](http://blog.csdn.net/ssjhust123/article/details/8035815#comments)

[huhuang03](http://blog.csdn.net/huhuang03): mark
* [中缀表达式转换为后缀表达式](http://blog.csdn.net/ssjhust123/article/details/8001651#comments)

[Flyhigh](http://blog.csdn.net/wjflyhigh): @naruto2011sasuke:不对，这里就不应该这么写，应该是只要有“（”，则直接进栈。进栈以...
* [中序遍历和先序遍历/后序遍历构建二叉树](http://blog.csdn.net/ssjhust123/article/details/7783935#comments)

[ssjhust123](http://blog.csdn.net/ssjhust123): @handong1587:呵呵，不客气。请多多指正。
* [中序遍历和先序遍历/后序遍历构建二叉树](http://blog.csdn.net/ssjhust123/article/details/7783935#comments)

[handong1587](http://blog.csdn.net/handong1587): 讲得很清楚，谢谢！
* [中缀表达式转换为后缀表达式](http://blog.csdn.net/ssjhust123/article/details/8001651#comments)

[haiyaojing](http://blog.csdn.net/haiyaojing): 灰常感谢~
* [中缀表达式转换为后缀表达式](http://blog.csdn.net/ssjhust123/article/details/8001651#comments)

[ssjhust123](http://blog.csdn.net/ssjhust123): @tcstory::-)，最近都没有时间写咯。
* [中缀表达式转换为后缀表达式](http://blog.csdn.net/ssjhust123/article/details/8001651#comments)

[tcstory](http://blog.csdn.net/tcstory): 师兄啊 代码啥时候贴上来啊
* [中缀表达式转换为后缀表达式](http://blog.csdn.net/ssjhust123/article/details/8001651#comments)

[tcstory](http://blog.csdn.net/tcstory): 谢谢了 写得非常好 比我的书《数据结构使用C语言》 第三版 朱战立 里面的 写得好多了

[公司简介](http://www.csdn.net/company/about.html)|[招贤纳士](http://www.csdn.net/company/recruit.html)|[广告服务](http://www.csdn.net/company/marketing.html)|[银行汇款帐号](http://www.csdn.net/company/account.html)|[联系方式](http://www.csdn.net/company/contact.html)|[版权声明](http://www.csdn.net/company/statement.html)|[法律顾问](http://www.csdn.net/company/layer.html)|[问题报告](mailto:webmaster@csdn.net)[QQ客服](http://wpa.qq.com/msgrd?v=3&uin=2355263776&site=qq&menu=yes) [微博客服](http://e.weibo.com/csdnsupport/profile) [论坛反馈](http://bbs.csdn.net/forums/Service) [联系邮箱：webmaster@csdn.net](mailto:webmaster@csdn.net) 服务热线：400-600-2320京 ICP 证 070598 号北京创新乐知信息技术有限公司 版权所有世纪乐知(北京)网络技术有限公司 提供技术支持江苏乐知网络技术有限公司 提供商务支持Copyright © 1999-2012, CSDN.NET, All Rights Reserved [![GongshangLogo]()](http://www.hd315.gov.cn/beian/view.asp?bianhao=010202001032100010)
![](http://counter.csdn.net/pv.aspx?id=24)
