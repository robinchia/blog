---
layout: post
title: "单向链表"
categories: Java&J2EE
tags: 
 - Java&J2EE
 - 算法&数组&优化
 - 算法
--- 

# 单向链表

### [单向链表](http://tangyanbo.iteye.com/blog/1472811)**

**博客分类：** 
* [数据结构](http://tangyanbo.iteye.com/category/214982)
[数据结构](http://www.iteye.com/blogs/tag/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)

**【链表】 
**是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。 
由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多， 
但是查找一个节点或者访问特定编号的节点则需要O(n)的时间， 
而顺序表相应的时间复杂度分别是O(㏒ n)和O(1)。 
**【单向链表】 
** 是链表的一种，其特点是链表的链接方向是单向的，对链表的访问要通过顺序读取从头部开始
  一个节点包含两个域，一个信息域和一个指针域，指针域指向下一个节点，最后一个节点指向一个空值
 单向链表有一个头节点，可以不存储任何信息，包含一个指向第一个节点的指针
 特点:
 1.访问节点速度慢，需要从头节点一次遍历链表
 2.更新节点快，节点不需要移动，更改相应指针即可 

 

单向链表节点类定义如下：

 
Java代码  [![收藏代码]()]( "收藏这段代码")

1. public class Node<AnyType>{  
1.   
1.     AnyType element;  
1.       
1.     Node<AnyType> next;     
1.   
1. }  

 

要实现单向列表的相关操作，可定义类SingleLinkedList如下：
Java代码  [![收藏代码]()]( "收藏这段代码")

1. public class SingleLinkedList<AnyType>{  
1.   
1.     private static class Node<AnyType>{  
1.   
1.         AnyType element;  
1.           
1.         Node<AnyType> next;     
1.           
1.         public Node(AnyType element){  
1.             this.element = element;  
1.         }  
1.   
1.     }  
1.       
1.     private Node<AnyType> header = new Node<AnyType>(null);  
1.       
1.     private int size = 0;  
1.       
1.     public boolean isEmpty(){  
1.         return size==0;  
1.     }  
1.       
1.     public void makeEmpty(){  
1.         header = null;  
1.     }  
1.       
1.     public int size(){  
1.         return size;  
1.     }   
1.       
1.     /** 
1.      * Get element by index 
1.      * */  
1.     public AnyType get(int index){        
1.         return getNode(index).element;  
1.     }  
1.       
1.     /** 
1.      * Add the element to the end of this list 
1.      * */  
1.     public void add(AnyType element){  
1.         add(new Node<AnyType>(element));  
1.     }  
1.       
1.     /** 
1.      * Inserts the specified element at the specified position in this list 
1.      * 插入逻辑： 
1.      * 1.创建一个新节点 
1.      * 2.将原index节点的前一个节点的指针指向新节点 
1.      * 3.将新节点的指针指向index节点 
1.      * 4.插入后，新节点的位置为index 
1.      * */  
1.     public void add(int index,AnyType element){  
1.         Node<AnyType> newNode = new Node<AnyType>(element);  
1.         Node<AnyType> previous = getNode(index-1);  
1.         //index节点  
1.         Node<AnyType> node = previous.next;  
1.         //将原index节点的前一个节点的指针指向newNode  
1.         previous.next = newNode;  
1.         //将newNode的指针指向index节点  
1.         newNode.next = node;  
1.         size++;  
1.     }  
1.       
1.     /** 
1.      * Inserts the specified element at the specified position in this list 
1.      * 删除逻辑： 
1.      * 1.获得index节点的前一个节点previousNode 
1.      * 2.获得index节点的后一个节点nextNode 
1.      * 3.将previousNode的指针指向nextNode 
1.      * */  
1.     public void remove(int index){  
1.         Node<AnyType> previous = getNode(index-1);  
1.         Node<AnyType> next = previous.next.next;  
1.         previous.next = next;  
1.         size--;  
1.     }  
1.   
1.       
1.     /** 
1.      * 定义此方法是为了便于测试 
1.      * */  
1.     public List<Integer> getElements(){  
1.         if(isEmpty()){  
1.             return null;  
1.         }else{  
1.             List<Integer> elements = new ArrayList<Integer>();  
1.             Node<AnyType> node = (Node<AnyType>) header;  
1.             while(node.next!=null){  
1.                 node = node.next;  
1.                 elements.add(((Element)node.element).getValue());  
1.             }  
1.             return elements;  
1.         }  
1.     }  
1.       
1.   
1.     //private methods  
1.     private Node<AnyType> getNode(int index){  
1.         if(isEmpty()){  
1.             throw new RuntimeException("List is empty");  
1.         }  
1.         int i = 0;  
1.         Node<AnyType> node = header;  
1.         while(i<=index){  
1.             node = node.next;  
1.             i++;  
1.         }  
1.         return node;  
1.     }  
1.       
1.     private void add(Node<AnyType> newNode){  
1.         Node<AnyType> node = header;  
1.         while(node.next!=null){  
1.             node = node.next;  
1.         }  
1.         node.next = newNode;  
1.         size++;  
1.     }  
1.           
1. }  

 

如何实现链表反向：
Java代码  [![收藏代码]()]( "收藏这段代码")

1. /** 
1.      * 链表反向 
1.      * */  
1.     public void reverse(){  
1.         if(!isEmpty()){  
1.             reverse(header.next,header.next.next);  
1.         }         
1.     }  

 

Java代码  [![收藏代码]()]( "收藏这段代码")

1. private void reverse(Node<AnyType> node,Node<AnyType> nextNode){  
1.         if(nextNode.next!=null){  
1.             reverse(nextNode,nextNode.next);              
1.         }else{  
1.             //如果该节点是表尾，那么用头节点指向此节点  
1.             header.next = nextNode;  
1.         }     
1.         //该节点的指针指向前一个节点P，并将节点P的指针设置为空  
1.         nextNode.next = node;  
1.         node.next = null;  
1.     }  

 

来源： <[http://tangyanbo.iteye.com/blog/1472811](http://tangyanbo.iteye.com/blog/1472811)> 
