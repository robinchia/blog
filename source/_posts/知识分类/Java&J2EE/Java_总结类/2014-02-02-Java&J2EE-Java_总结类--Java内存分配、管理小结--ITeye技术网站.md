---
layout: post
title: "Java内存分配、管理小结 - - ITeye技术网站"
categories: Java&J2EE
tags: 
 - Java&J2EE
 - Java_总结类
--- 

# Java内存分配、管理小结 - - ITeye技术网站

[首页](http://www.iteye.com/) [新闻](http://www.iteye.com/news) [论坛](http://www.iteye.com/forums) [问答](http://www.iteye.com/ask) [博客](http://www.iteye.com/blogs) [招聘](http://www.iteye.com/job) [更多 ▼](http://java-mzd.iteye.com/blog/848635#)

[专栏](http://www.iteye.com/wiki)  [群组](http://www.iteye.com/groups) [搜索](http://www.iteye.com/search)

[您还未登录 !](http://java-mzd.iteye.com/login "登录") [我的应用](http://www.iteye.com/all) [登录](http://java-mzd.iteye.com/login) [注册](http://java-mzd.iteye.com/signup)

# [java-mzd](http://java-mzd.iteye.com/)

永久域名 [http://java-mzd.iteye.com](http://java-mzd.iteye.com/)

[55顶](http://java-mzd.iteye.com/blog/848635#)
[8踩](http://java-mzd.iteye.com/blog/848635#)

[开源软件？自由软件？免费软件？你了解多少 ...](http://java-mzd.iteye.com/blog/862787 "开源软件？自由软件？免费软件？你了解多少？") | [JAVA程序执行顺序，你了解了吗？](http://java-mzd.iteye.com/blog/838683 "JAVA程序执行顺序，你了解了吗？")

2010-12-21

### [Java内存分配、管理小结]()

**文章分类:[Java编程](http://www.iteye.com/blogs/category/java)**
P.S.

想写这篇总结酝酿了有个来月了，却始终感觉还差点什么东西，一直未敢动笔。

       最近两天连夜奋战，重新整理下前面查阅的资料、笔记，还是决定将它写出来。

       现在提出几个问题，如果都能熟练回答的大虾，请您飘过.如以往一样，我是小菜，本文自然也是针对小菜阶层的总结。

 

首先是概念层面的几个问题：

 

* Java中运行时内存结构有哪几种？
* Java中为什么要设计堆栈分离?
* Java多线程中是如何实现数据共享的？
* Java反射的基础是什么？

然后是运用层面：

* 引用类型变量和对象的区别？
* 什么情况下用局部变量，什么情况下用成员变量？
* 数组如何初始化？声明一个数组的过程中，如何分配内存？
* 声明基本类型数组和声明引用类型的数组，初始化时，内存分配机制有什么区？
* 在什么情况下，我们的方法设计为静态化，为什么？（上次胡老师问文奇，问的哑口无言，当时想回答，却老感觉表述不清楚，这里也简单说明一下）

好了，问题提完了，如果您都能一眼看出答案，那么，没有必要再浪费您宝贵的时间看下去了。

如果您还不太明白，请跟随我一路走下去。

 

Java中运行时内存结构

   1.1 方法区： 

**方法区是系统分配的一个内存逻辑区域，是JVM在装载类文件时，用于存储类型信息的(类的描述信息)。**

    

方法区存放的信息包括：

            1.1.1**类的基本信息：**

1. 每个类的全限定名
1. 每个类的直接超类的全限定名(可约束类型转换)
1. 该类是类还是接口
1. 该类型的访问修饰符
1. 直接超接口的全限定名的有序列表

             1.1.2**已装载类的详细信息**：

1.  运行时常量池：

在方法区中，每个类型都对应一个常量池，存放该类型所用到的所有常量，常量池中存储了诸如文字字符串、final变量值、类名和方法名常量。它们以数组形式通过索引被访问，是外部调用与类联系及类型对象化的桥梁。（存的可能是个普通的字符串，然后经过常量池解析，则变成指向某个类的引用）
1.  字段信息：

字段信息存放类中声明的每一个字段的信息，包括字段的名、类型、修饰符。

字段名称指的是类或接口的实例变量或类变量，字段的描述符是一个指示字段的类型的字符串，如private A a=null;则a为字段名，A为描述符，private为修饰符
1.  方法信息：

类中声明的每一个方法的信息，包括方法名、返回值类型、参数类型、修饰符、异常、方法的字节码。

(在编译的时候，就已经将方法的局部变量、操作数栈大小等确定并存放在字节码中，在装载的时候，随着类一起装入方法区。)
在运行时，JVM从常量池中获得符号引用，然后在运行时解析成引用项的实际地址，最后通过常量池中的全限定名、方法和字段描述符，把当前类或接口中的代码与其它类或接口中的代码联系起来。
1.  静态变量：

这个没什么好说的，就是类变量，类的所有实例都共享，我们只需知道，在方法区有个静态区，静态区专门存放静态变量和静态块。
1.  到类classloader的引用：到该类的类装载器的引用。
1.  到类class 的引用：虚拟机为每一个被装载的类型创建一个class 实例，用来代表这个被装载的类。 

   **由此我们可以知道反射的基础**：

在装载类的时候，加入方法区中的所有信息，最后都会形成Class类的实例，代表这个被装载的类。方法区中的所有的信息，都是可以通过这个Class类对象反射得到。我们知道对象是类的实例，类是相同结构的对象的一种抽象。同类的各个对象之间，其实是拥有相同的结构（属性），拥有相同的功能（方法），各个对象的区别只在于属性值的不同。
    同样的，我们所有的类，其实都是Class类的实例，他们都拥有相同的结构-----Field数组、Method数组。而各个类中的属性都是Field属性的一个具体属性值，方法都是Method属性的一个具体属性值。

 

 在运行时，JVM从常量池中获得符号引用，然后在运行时解析成引用项的实际地址，最后通过常量池中的全限定名、方法和字段描述符，把当前类或接口中的代码与其它类或接口中的代码联系起来。

 

1.2 Java栈

JVM栈是程序运行时单位，决定了程序如何执行，或者说数据如何处理。

在Java中，一个线程就会有一个线程的JVM栈与之对应，因为不过的线程执行逻辑显然不同，因此都需要一个独立的JVM栈来存放该线程的执行逻辑。

对方法的调用：

Java栈内存，以帧的形式存放本地方法的调用状态，包括方法调用的参数、局部变量、中间结果等（方法都是以方法帧的形式存放在方法区的），每调用一个方法就将对应该方法的方法帧压入Java 栈，成为当前方法帧。当调用结束(返回)时，就弹出该帧。

 

**这意味着：**

在方法中定义的一些基本类型的变量和引用变量都在方法的栈内存中分配。**当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后（方法执行完成后），Java 会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作它用**。--------**同时，因为变量被释放，该变量对应的对象，也就失去了引用，也就变成了可以被gc对象回收的垃圾。**

**因此我们可以知道成员变量与局部变量的区别：**

局部变量，在方法内部声明，当该方法运行完时，内存即被释放。
成员变量，只要该对象还在，哪怕某一个方法运行完了，还是存在。
从系统的角度来说，声明局部变量有利于内存空间的更高效利用（方法运行完即回收）。
成员变量可用于各个方法间进行数据共享。

 

 

Java 栈内存的组成：
局部变量区、操作数栈、帧数据区组成。
（1）：局部变量区为一个以字为单位的数组，每个数组元素对应一个局部变量的值。调用方法时，将方法的局部变量组成一个数组，通过索引来访问。若为非静态方法，则加入一个隐含的引用参数this,该参数指向调用这个方法的对象。而静态方法则没有this参数。因此，对象无法调用静态方法。

 

**由此，我们可以知道，方法什么时候设计为静态，什么时候为非静态？**

前面已经说过，对象是类的一个实例，各个对象结构相同，只是属性不同。
而静态方法是对象无法调用的。
所以，静态方法适合那些工具类中的工具方法，这些类只是用来实现一些功能，也不需要产生对象，通过设置对象的属性来得到各个不同的个体。

（2）：操作数栈也是一个数组，但是通过栈操作来访问。所谓操作数是那些被指令操作的数据。当需要对参数操作时如a=b+c,就将即将被操作的参数压栈，如将b 和c 压栈，然后由操作指令将它们弹出，并执行操作。虚拟机将操作数栈作为工作区。
（3）：帧数据区处理常量池解析，异常处理等

 

1.3 java堆 

      java的堆是一个运行时的数据区，用来存储数据的单元，存放通过new关键字新建的对象和数组，对象从中分配内存。
      在堆中声明的对象，是不能直接访问的，必须通过在栈中声明的指向该引用的变量来调用。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。
   

    ** 由此我们可以知道,引用类型变量和对象的区别: **

声明的对象是在堆内存中初始化的， 真正用来存储数据的。不能直接访问。

引用类型变量是保存在栈当中的，一个用来引用堆中对象的符号而已（指针）。

**堆与栈的比较**：
JAVA堆与栈都是用来存放数据的，那么他们之间到底有什么差异呢？既然栈也能存放数据，为什么还要设计堆呢？

1.从存放数据的角度:

      前面我们已经说明:

      栈中存放的是基本类型的变量or引用类型的变量

       堆中存放的是对象or数组对象.

       在栈中，引用变量的大小为32位，基本类型为1-8个字节。
       但是对象的大小和数组的大小是动态的，这也决定了堆中数据的动态性，因为它是在运行时动态分配内存的，生存期也不必在编译时确定，Java 的垃圾收集器会自动收走这些不再使用的数据。

 

2.**从数据共享的角度**:

    1).在单个线程类，栈中的数据可共享

    例如我们定义：
Java代码  [![收藏代码]()![]()]( "收藏这段代码")

1. int a=3;  
1. int b=3;  
int a=3; int b=3;

    编译器先处理int a = 3；首先它会在栈中创建一个变量为a 的引用，然后查找栈中是否有3 这个值，如果没找到，就将3 存放进来，然后将a 指向3。接着处理int b = 3；在创建完b 的引用变量后，因为在栈中已经有3这个值，便将b 直接指向3。这样，就出现了a 与b 同时均指向3的情况。

    而如果我们定义： 
Java代码  [![收藏代码]()![]()]( "收藏这段代码")

1. Integer a=new Integer(3);//(1)  
1. Integer b=new Integer(3);//(2)  
Integer a=new Integer(3);//(1) Integer b=new Integer(3);//(2)

   这个时候执行过程为：在执行(1)时，首先在栈中创建一个变量a，然后在堆内存中实例化一个对象，并且将变量a指向这个实例化的对象。在执行(2)时，过程类似，此时，在堆内存中，会有两个Integer类型的对象。 

 

    2).**在进程的各个线程之间，数据的共享通过堆来实现**

        例：那么，在多线程开发中，我们的数据共享又是怎么实现的呢？
![]()

 

  如图所示，堆中的数据是所有线程栈所共享的，我们可以通过参数传递，将一个堆中的数据传入各个栈的工作内存中，从而实现多个线程间的数据共享

（多个进程间的数据共享则需要通过网络传输了。） 

 

3.从程序设计的的角度:

从软件设计的角度看，JVM栈代表了处理逻辑，而JVM堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。

4.值传递和引用传递的真相

有了以上关于栈和堆的种种了解后，我们很容易就可以知道值传递和引用传递的真相：

1.程序运行永远都是在JVM栈中进行的，因而参数传递时，只存在传递基本类型和对象引用的问题。不会直接传对象本身。

但是传引用的错觉是如何造成的呢?

在运行JVM栈中，基本类型和引用的处理是一样的，都是传值，所以，如果是传引用的方法调用，也同时可以理解为“传引用值”的传值调用，即引用的处理跟基本类型是完全一样的。

但是当进入被调用方法时，被传递的这个引用的值，被程序解释(或者查找)到JVM堆中的对象，这个时候才对应到真正的对象。

如果此时进行修改，修改的是引用对应的对象，而不是引用本身，即：修改的是JVM堆中的数据。所以这个修改是可以保持的了。

 

 

最后：

从某种意义上来说对象都是由基本类型组成的。 

可以把一个对象看作为一棵树，对象的属性如果还是对象，则还是一颗树(即非叶子节点)，基本类型则为树的叶子节点。程序参数传递时，被传递的值本身都是不能进行修改的，但是，如果这个值是一个非叶子节点(即一个对象引用)，则可以修改这个节点下面的所有内容。 

**其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别**。

面向对象的引入，只是改变了我们对待问题的思考方式，而更接近于自然方式的思考。

当我们把对象拆开，其实对象的属性就是数据，存放在JVM堆中;而对象的行为(方法)，就是运行逻辑，放在JVM栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。 

 

 

P.S

关于数组的内存分配，对象初始化的内存分配等问题，由于篇幅问题，下次再搞个专题写吧。

 连续几天几夜对着此文了。想吐的很，先到这里吧。

* [![]( "点击查看原始大小图片")]()
* 大小: 13.2 KB

* [查看图片附件](http://java-mzd.iteye.com/blog/848635#)
[**55**
顶](http://java-mzd.iteye.com/blog/848635#)[**8**
踩](http://java-mzd.iteye.com/blog/848635#)

[开源软件？自由软件？免费软件？你了解多少 ...](http://java-mzd.iteye.com/blog/862787 "开源软件？自由软件？免费软件？你了解多少？") | [JAVA程序执行顺序，你了解了吗？](http://java-mzd.iteye.com/blog/838683 "JAVA程序执行顺序，你了解了吗？")
* 20:46
* 浏览 (10080)
* [评论](http://java-mzd.iteye.com/blog/848635#comments) (20)
* [相关推荐](http://www.iteye.com/wiki/topic/848635)

### 评论

[]()

20 楼 [zkgale](http://zkgale.iteye.com/) 2011-01-14   [引用](http://java-mzd.iteye.com/blog/848635#)

满好的,谢谢你
不过,可能还是象前面几位说的那样吧,在分配的细节上写得还不是很深入,
不管怎么说,让我在引用关系方面的理解更深入了一些.
继续加油,很给力
19 楼 [z_jiankun](http://z-jiankun.iteye.com/) 2011-01-06   [引用](http://java-mzd.iteye.com/blog/848635#)

zzc_zj 写道

分析得很细致，一遍没完全看明白，收藏下来，继续看
同感

18 楼 [anmo](http://anmo.iteye.com/) 2011-01-05   [引用](http://java-mzd.iteye.com/blog/848635#)

总结的有深度，学习一下！
17 楼 [wanglong1615](http://wanglong1615.iteye.com/) 2011-01-04   [引用](http://java-mzd.iteye.com/blog/848635#)

JAVA堆与栈都是用来存放数据的，那么他们之间到底有什么差异呢？既然栈也能存放数据，为什么还要设计堆呢？
我觉得还有一个原因，也就是为什么有基本类型和基本类型的包装类一样。
在JAVA中，基本类型是经常被使用和运算的，设计基本类型，最主要是节约性能的考虑。

16 楼 [javahero1984](http://javahero1984.iteye.com/) 2011-01-03   [引用](http://java-mzd.iteye.com/blog/848635#)

不错，至少楼主是用心总结了，值得学习和讨论。
15 楼 [culbertzp](http://culbertzp.iteye.com/) 2010-12-30   [引用](http://java-mzd.iteye.com/blog/848635#)

bu_choreography 写道

2.从数据共享的角度:.
这块对整型的引用讲的很好。
补充一点：整型在常量池里只能表示-128到127.超过这个范围的就不归常量池管了
例如
Integer a = 128;
Integer b = 128;
a==b  返回的是false.
如果：
Integer a = 128;
int b = 128;
a == b 返回的是true
int a = 128;
int b = 128;
a == b 返回的也是true

14 楼 [Irving_wei](http://irving-wei.iteye.com/) 2010-12-28   [引用](http://java-mzd.iteye.com/blog/848635#)

  挺不错
13 楼 [CosmosWon](http://cosmoswon.iteye.com/) 2010-12-27   [引用](http://java-mzd.iteye.com/blog/848635#)

明白了，但是我觉得楼主在这段上还有待斟酌：
（当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后（方法执行完成后），Java 会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作它用。--------同时，因为变量被释放，该变量对应的对象，也就失去了引用，也就变成了可以被gc对象回收的垃圾。）
当然了，本文也不是在讨论垃圾回收的，呵呵，不过既然说了，应该在说的精确点。

12 楼 [hjk685](http://hjk685.iteye.com/) 2010-12-24   [引用](http://java-mzd.iteye.com/blog/848635#)

很有条理
11 楼 [java_mzd](http://java-mzd.iteye.com/) 2010-12-23   [引用](http://java-mzd.iteye.com/blog/848635#)

eXeSP 写道

查了下以前的帖子：
引用

java虚拟机规范中说：Primitive values do not share state with other primitive values. A variable whose type is a primitive type always holds a primitive value of that type.
看一下实际的处理情况:
  int a=3;
  int b=3;
打开class文件，这2句就4个字节，内容是“06 3B 06 3C”
看对应的虚拟机指令，可以知道变量里实际存储的是什么:
Code:
  0: iconst_3 //3
  1: istore_1
  2: iconst_3 //3
  3: istore_2
第1个字节06 iconst_3是一个指令，让CPU把寄存器放上3的值
第2个字节3B istore_0也是一个指令，就是让CPU把寄存器的值放到第1个变量的内存中
第3个字节06 iconst_3是一个指令，让CPU把寄存器放上3的值
第4个字节3C istore_1也是一个指令，就是让CPU把寄存器的值放到第2个变量的内存中
（jvm没有“寄存器”的概念，用“Operand Stack 操作数栈”。）
int a = 3，int b =3是直接从指令获取数值，而没有进行栈中交换或进入常量池。
引用

这里可以看到JAVA虚拟机的一个小技巧，它把一些对常用常量（比如0,1,2,3,4,5）的操作直接定义成了指令，而不是传统的操作指令后带操作数。
目的是减少指令长度。有心的人再用 int a = 6...试，根本就没有iconst_6的指令！
而是bipush 6，机器码10 06, 2个字节，10就是bipush， 06就是操作数6，就是传统的指令＋操作数。
那么大于6的数呢
引用

int e=32330;
对应指令：
11: sipush 32330
14: istore 5
这句,11-13,正好是3个字节的指令大小,一个字节是sipush指令,2个字节用来存储32330这个数.两次使用到这个数,都是把它直接存给变量的。
那么如果大于2个字节的数又如何？
引用

int f = 65535;
对应指令:
4: ldc #2; //int 65535
6: istore_3
对于65535,它是大于两个字节的,编译的时候把它放入常量池部分,而把取这个数的指令写为ldc#2,我感觉这样一个直观的好处是减少了指令代码的长度.尤其是多次使用到一个相同的数时
.
大于2个字节的int数值，开始进入常量池。
那么int和Integer一样吗？
引用

Integer i = 3；
sun的编译器是这样处理的:
Integer i=Integer.valueOf(3);
而不是通过new来创建了,因为Integer类中静态的创建了-128~+127之间的对象,需要的数在这个范围之内时,直接返回,此范围之外的数才通过new来创建.
多谢多谢。  我还真没注意在cpu中到底怎么处理这部分。
受教了。

10 楼 [生活小丑](http://laozhu1662006-126-com.iteye.com/) 2010-12-22   [引用](http://java-mzd.iteye.com/blog/848635#)

java内存分配方面的知识一直都是朦朦胧胧的，说知道说不清楚，说不知道，还有点知道，网上搜了好多文章，楼主的文章算是比较详细的了.
9 楼 [eXeSP](http://exesp.iteye.com/) 2010-12-22   [引用](http://java-mzd.iteye.com/blog/848635#)

查了下以前的帖子：
引用

java虚拟机规范中说：Primitive values do not share state with other primitive values. A variable whose type is a primitive type always holds a primitive value of that type.
看一下实际的处理情况:
  int a=3;
  int b=3;
打开class文件，这2句就4个字节，内容是“06 3B 06 3C”
看对应的虚拟机指令，可以知道变量里实际存储的是什么:
Code:
  0: iconst_3 //3
  1: istore_1
  2: iconst_3 //3
  3: istore_2
第1个字节06 iconst_3是一个指令，让CPU把寄存器放上3的值
第2个字节3B istore_0也是一个指令，就是让CPU把寄存器的值放到第1个变量的内存中
第3个字节06 iconst_3是一个指令，让CPU把寄存器放上3的值
第4个字节3C istore_1也是一个指令，就是让CPU把寄存器的值放到第2个变量的内存中
（jvm没有“寄存器”的概念，用“Operand Stack 操作数栈”。）
int a = 3，int b =3是直接从指令获取数值，而没有进行栈中交换或进入常量池。
引用

这里可以看到JAVA虚拟机的一个小技巧，它把一些对常用常量（比如0,1,2,3,4,5）的操作直接定义成了指令，而不是传统的操作指令后带操作数。
目的是减少指令长度。有心的人再用 int a = 6...试，根本就没有iconst_6的指令！
而是bipush 6，机器码10 06, 2个字节，10就是bipush， 06就是操作数6，就是传统的指令＋操作数。
那么大于6的数呢
引用

int e=32330;
对应指令：
11: sipush 32330
14: istore 5
这句,11-13,正好是3个字节的指令大小,一个字节是sipush指令,2个字节用来存储32330这个数.两次使用到这个数,都是把它直接存给变量的。
那么如果大于2个字节的数又如何？
引用

int f = 65535;
对应指令:
4: ldc #2; //int 65535
6: istore_3
对于65535,它是大于两个字节的,编译的时候把它放入常量池部分,而把取这个数的指令写为ldc#2,我感觉这样一个直观的好处是减少了指令代码的长度.尤其是多次使用到一个相同的数时
.
大于2个字节的int数值，开始进入常量池。
那么int和Integer一样吗？
引用

Integer i = 3；
sun的编译器是这样处理的:
Integer i=Integer.valueOf(3);
而不是通过new来创建了,因为Integer类中静态的创建了-128~+127之间的对象,需要的数在这个范围之内时,直接返回,此范围之外的数才通过new来创建.

8 楼 [eXeSP](http://exesp.iteye.com/) 2010-12-22   [引用](http://java-mzd.iteye.com/blog/848635#)

在方法区，Integer类中静态的创建了-128~+127之间的对象。int a = 3的数值是从常量池返回到栈当中的吧，想问问int b = 3，b是先从栈还是先从常量池查找数值，印象中String的话是从常量池查找的。
7 楼 [iuf6853](http://iuf6853.iteye.com/) 2010-12-22   [引用](http://java-mzd.iteye.com/blog/848635#)

辛苦了，让出入java圣殿的门外汉们受益匪浅。

6 楼 [zzc_zj](http://zcj.iteye.com/) 2010-12-22   [引用](http://java-mzd.iteye.com/blog/848635#)

分析得很细致，一遍没完全看明白，收藏下来，继续看
5 楼 [java_mzd](http://java-mzd.iteye.com/) 2010-12-22   [引用](http://java-mzd.iteye.com/blog/848635#)

juda 写道

写的不错，鼓励一下
多谢鼓励。
继续加油。

4 楼 [java_mzd](http://java-mzd.iteye.com/) 2010-12-22   [引用](http://java-mzd.iteye.com/blog/848635#)

bu_choreography 写道

2.从数据共享的角度:.
这块对整型的引用讲的很好。
补充一点：整型在常量池里只能表示-128到127.超过这个范围的就不归常量池管了
例如
Integer a = 128;
Integer b = 128;
a==b  返回的是false.
多谢指导，意思就是现在常量池整形只能存一个字节？
  那么关于double等类型的是不是也有相应变化呢？
最近借不到《深入JVM》
还是再查查资料吧。
多些指导
3 楼 [juda](http://juda.iteye.com/) 2010-12-22   [引用](http://java-mzd.iteye.com/blog/848635#)

写的不错，鼓励一下

2 楼 [bu_choreography](http://bu-choreography.iteye.com/) 2010-12-21   [引用](http://java-mzd.iteye.com/blog/848635#)

2.从数据共享的角度:.
这块对整型的引用讲的很好。
补充一点：整型在常量池里只能表示-128到127.超过这个范围的就不归常量池管了
例如
Integer a = 128;
Integer b = 128;
a==b  返回的是false.
1 楼 [javafound](http://javafound.iteye.com/) 2010-12-21   [引用](http://java-mzd.iteye.com/blog/848635#)

还算给力,鼓励一下，
### 发表评论

### 表情图标

![]()![]()![]()![]()![]()![]()![]()![]()![]()![]()![]()![]()![]()![]()![]()![]()![]()![]()![]()![]()

字体颜色: 标准深红红色橙色棕色黄色绿色橄榄青色蓝色深蓝靛蓝紫色灰色白色黑色 字体大小: 标准1 (xx-small)2 (x-small)3 (small)4 (medium)5 (large)6 (x-large)7 (xx-large) 对齐: 标准居左居中居右

提示：选择您需要装饰的文字, 按上列按钮即可添加上相应的标签

您还没有登录，请[登录](http://java-mzd.iteye.com/login)后发表评论(快捷键 Alt+S / Ctrl+Enter)

[![java_mzd的博客]( "java_mzd的博客: ")](http://java-mzd.iteye.com/)

java_mzd

* 浏览: 70749 次
* 性别: ![Icon_minigender_1]( "男")
* 来自: 长沙
* ![]()
* [详细资料](http://java-mzd.iteye.com/blog/profile) [留言簿](http://java-mzd.iteye.com/blog/guest_book)

### 搜索本博客
### 最近访客 [>>更多访客](http://java-mzd.iteye.com/blog/user_visits)

[![zhxing的博客]( "zhxing的博客: ヾ孤星随缘ツ  http://t.sina.com.cn/samzhxing")](http://zhxing.iteye.com/)

[zhxing](http://zhxing.iteye.com/)

[![java_suddy的博客]( "java_suddy的博客: “平凡”的思想")](http://java-suddy.iteye.com/)

[java_suddy](http://java-suddy.iteye.com/)
[![liuxinglanyue的博客]( "liuxinglanyue的博客: liuxinglanyue")](http://liuxinglanyue.iteye.com/)

[liuxinglanyue](http://liuxinglanyue.iteye.com/)

[![libo_591的博客]( "libo_591的博客: 让更多的人站在巨人的肩膀上")](http://libo-591.iteye.com/)

[libo_591](http://libo-591.iteye.com/)

### 博客分类

* [全部博客 (43)](http://java-mzd.iteye.com/)
* [数据结构----------JAVA类集 (5)](http://java-mzd.iteye.com/category/133623)
* [TCP/IP (7)](http://java-mzd.iteye.com/category/153171)
### 我的留言簿 [>>更多留言](http://java-mzd.iteye.com/blog/guest_book)

* 楼主 你工作多久了。。。。
-- by [fanmingxing](http://java-mzd.iteye.com/blog/guest_book#39913)
* 写的不错，学习，谢谢！
-- by [chenge2k](http://java-mzd.iteye.com/blog/guest_book#39693)
* 看了LZ的文章，发现工作快两年的我，就像是一块浮起来的木头，真的很惭愧！也不怪我拿 ...
-- by [GoTiger](http://java-mzd.iteye.com/blog/guest_book#39618)

### 其他分类

* [我的收藏](http://java-mzd.iteye.com/blog/favorite) (23)
* [我的代码](http://java-mzd.iteye.com/blog/code_favorite) (0)
* [我的论坛主题帖](http://java-mzd.iteye.com/blog/topic) (3)
* [我的所有论坛帖](http://java-mzd.iteye.com/blog/post) (37)
* [我的精华良好帖](http://java-mzd.iteye.com/blog/article) (0)
### 最近加入群组

* [Android](http://android.group.iteye.com/)

### 存档

* [2011-05](http://java-mzd.iteye.com/blog/monthblog/2011-05) (2)
* [2011-04](http://java-mzd.iteye.com/blog/monthblog/2011-04) (7)
* [2011-03](http://java-mzd.iteye.com/blog/monthblog/2011-03) (2)
* [更多存档...](http://java-mzd.iteye.com/blog/monthblog_more)
### 评论排行榜

* [腾讯、淘宝、金山网络，实习生我该何去何从](http://java-mzd.iteye.com/blog/1050043 "腾讯、淘宝、金山网络，实习生我该何去何从")
* [淘宝、金山网络，百感交集](http://java-mzd.iteye.com/blog/1050926 "淘宝、金山网络，百感交集")
* [TCP/IP传输层，你懂多少？](http://java-mzd.iteye.com/blog/1007577 "TCP/IP传输层，你懂多少？")
* [淘宝武汉*面试归来](http://java-mzd.iteye.com/blog/1004784 "淘宝武汉*面试归来")
* [开源软件？自由软件？免费软件？你了解多少 ...](http://java-mzd.iteye.com/blog/862787 "开源软件？自由软件？免费软件？你了解多少？")

* [![Rss]()](http://java-mzd.iteye.com/rss)
* [![Rss_google]()](http://fusion.google.com/add?feedurl=http://java-mzd.iteye.com/rss)
声明：ITeye文章版权属于作者，受法律保护。没有作者书面许可不得转载。若作者同意转载，必须以超链接形式标明文章原始出处和作者。
© 2003-2011 ITeye.com. All rights reserved. [ 京ICP证110151号 ]
![]()
