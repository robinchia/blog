---
layout: post
title: "druid 教程"
categories: 连接池
tags: 
 - 连接池
--- 

# druid 教程

     java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，有不得不使用数据库连接池。数据库连接池有很多选择，c3p、dhcp、proxool等，druid作为一名后起之秀，凭借其出色的性能，也逐渐印入了大家的眼帘。接下来本教程就说一下druid的简单使用。

 首先从[http://repo1.maven.org/maven2/com/alibaba/druid/](http://repo1.maven.org/maven2/com/alibaba/druid/) 下载最新的jar包。如果想使用最新的源码编译，可以从[https://github.com/alibaba/druid](https://github.com/alibaba/druid) 下载源码，然后使用maven命令行，或者导入到eclipse中进行编译。

## []()1 配置

和dbcp类似，druid的配置项如下

配置 缺省值 说明 name   配置这个属性的意义在于，如果存在多个数据源，监控的时候
可以通过名字来区分开来。如果没有配置，将会生成一个名字，
格式是："DataSource-" + System.identityHashCode(this) jdbcUrl   连接数据库的url，不同数据库不一样。例如：
mysql : jdbc:mysql://10.20.153.104:3306/druid2 
oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username   连接数据库的用户名 password   连接数据库的密码。如果你不希望密码直接写在配置文件中，
可以使用ConfigFilter。详细看这里：
[https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter](https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter) driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，
然后选择相应的driverClassName initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，
或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle   最小连接池数量 maxWait   获取连接时最大等待时间，单位毫秒。配置了maxWait之后，
缺省启用公平锁，并发效率会有所下降，
如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。
PSCache对支持游标的数据库性能提升巨大，比如说oracle。
在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，
poolPreparedStatements自动触发修改为true。
在Druid中，不会存在Oracle下PSCache占用内存过多的问题，
可以把这个数值配置大一些，比如说100 validationQuery   用来检测连接是否有效的sql，要求是一个查询语句。
如果validationQuery为null，testOnBorrow、testOnReturn、
testWhileIdle都不会其作用。 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，
做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，
做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。
申请连接的时候检测，如果空闲时间大于
timeBetweenEvictionRunsMillis，
执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis   有两个含义：
1) Destroy线程会检测连接的间隔时间
 2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun   不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis     connectionInitSqls   物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters   属性类型是字符串，通过别名的方式配置扩展插件，
常用的插件有：
监控统计用的filter:stat 
日志用的filter:log4j
 防御sql注入的filter:wall proxyFilters   类型是List<com.alibaba.druid.filter.Filter>，
如果同时配置了filters和proxyFilters，
是组合关系，并非替换关系**表1.1 配置属性**

根据常用的配置属性，首先给出一个如下的配置文件，放置于src目录下。

**[plain]** [view plain](http://blog.csdn.net/yunnysunny/article/details/8657095# "view plain")[copy](http://blog.csdn.net/yunnysunny/article/details/8657095# "copy")

1. url:jdbc:mysql://localhost:3306/dragoon_v25_masterdb  
1. driverClassName:com.mysql.jdbc.Driver  
1. username:root  
1. password:aaaaaaaa  
1.        
1. filters:stat  
1.    
1. maxActive:20  
1. initialSize:1  
1. maxWait:60000  
1. minIdle:10  
1. #maxIdle:15  
1.    
1. timeBetweenEvictionRunsMillis:60000  
1. minEvictableIdleTimeMillis:300000  
1.    
1. validationQuery:SELECT 'x'  
1. testWhileIdle:true  
1. testOnBorrow:false  
1. testOnReturn:false  
1. #poolPreparedStatements:true  
1. maxOpenPreparedStatements:20  
1.   
1. #对于长时间不使用的连接强制关闭  
1. removeAbandoned:true  
1. #超过30分钟开始关闭空闲连接  
1. removeAbandonedTimeout:1800  
1. #将当前关闭动作记录到日志  
1. logAbandoned:true  

**配置文件1.1 **

配置项中指定了各个参数后，在连接池内部是这么使用这些参数的。数据库连接池在初始化的时候会创建initialSize个连接，当有数据库操作时，会从池中取出一个连接。如果当前池中正在使用的连接数等于maxActive，则会等待一段时间，等待其他操作释放掉某一个连接，如果这个等待时间超过了maxWait，则会报错；如果当前正在使用的连接数没有达到maxActive，则判断当前是否空闲连接，如果有则直接使用空闲连接，如果没有则新建立一个连接。在连接使用完毕后，不是将其物理连接关闭，而是将其放入池中等待其他操作复用。

同时连接池内部有机制判断，如果当前的总的连接数少于miniIdle，则会建立新的空闲连接，以保证连接数得到miniIdle。如果当前连接池中某个连接在空闲了timeBetweenEvictionRunsMillis时间后任然没有使用，则被物理性的关闭掉。有些数据库连接的时候有超时限制（mysql连接在8小时后断开），或者由于网络中断等原因，连接池的连接会出现失效的情况，这时候设置一个testWhileIdle参数为true，可以保证连接池内部定时检测连接的可用性，不可用的连接会被抛弃或者重建，最大情况的保证从连接池中得到的Connection对象是可用的。当然，为了保证绝对的可用性，你也可以使用testOnBorrow为true（即在获取Connection对象时检测其可用性），不过这样会影响性能。

## []()2 代码编写

### []()2.1 使用spring

首先给出spring配置文件

**[html]** [view plain](http://blog.csdn.net/yunnysunny/article/details/8657095# "view plain")[copy](http://blog.csdn.net/yunnysunny/article/details/8657095# "copy")

1. <?xml version="1.0" encoding="UTF-8"?>  
1. <beans xmlns="http://www.springframework.org/schema/beans"  
1.     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
1.     xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd  
1.         http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  
1.         http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd">  
1.     <!-- 给web使用的spring文件 -->  
1.     <bean id="propertyConfigurer"  
1.         class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">  
1.         <property name="locations">  
1.             <list>  
1.                 <value>/WEB-INF/classes/dbconfig.properties</value>  
1.             </list>  
1.         </property>  
1.     </bean>  
1.     <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"  
1.         destroy-method="close">  
1.         <property name="url" value="${url}" />  
1.         <property name="username" value="${username}" />  
1.         <property name="password" value="${password}" />  
1.         <property name="driverClassName" value="${driverClassName}" />  
1.         <property name="filters" value="${filters}" />  
1.   
1.         <property name="maxActive" value="${maxActive}" />  
1.         <property name="initialSize" value="${initialSize}" />  
1.         <property name="maxWait" value="${maxWait}" />  
1.         <property name="minIdle" value="${minIdle}" />  
1.   
1.         <property name="timeBetweenEvictionRunsMillis" value="${timeBetweenEvictionRunsMillis}" />  
1.         <property name="minEvictableIdleTimeMillis" value="${minEvictableIdleTimeMillis}" />  
1.   
1.         <property name="validationQuery" value="${validationQuery}" />  
1.         <property name="testWhileIdle" value="${testWhileIdle}" />  
1.         <property name="testOnBorrow" value="${testOnBorrow}" />  
1.         <property name="testOnReturn" value="${testOnReturn}" />  
1.         <property name="maxOpenPreparedStatements"  
1.             value="${maxOpenPreparedStatements}" />  
1.         <property name="removeAbandoned" value="${removeAbandoned}" /> <!-- 打开removeAbandoned功能 -->  
1.         <property name="removeAbandonedTimeout" value="${removeAbandonedTimeout}" /> <!-- 1800秒，也就是30分钟 -->  
1.         <property name="logAbandoned" value="${logAbandoned}" /> <!-- 关闭abanded连接时输出错误日志 -->  
1.     </bean>  
1.       
1.     <bean id="dataSourceDbcp" class="org.apache.commons.dbcp.BasicDataSource"  
1.         destroy-method="close">  
1.   
1.         <property name="driverClassName" value="${driverClassName}" />  
1.         <property name="url" value="${url}" />  
1.         <property name="username" value="${username}" />  
1.         <property name="password" value="${password}" />  
1.           
1.         <property name="maxActive" value="${maxActive}" />  
1.         <property name="minIdle" value="${minIdle}" />  
1.         <property name="maxWait" value="${maxWait}" />  
1.         <property name="defaultAutoCommit" value="true" />  
1.           
1.         <property name="timeBetweenEvictionRunsMillis" value="${timeBetweenEvictionRunsMillis}" />  
1.         <property name="minEvictableIdleTimeMillis" value="${minEvictableIdleTimeMillis}" />  
1.           
1.         <property name="validationQuery" value="${validationQuery}" />  
1.         <property name="testWhileIdle" value="${testWhileIdle}" />  
1.         <property name="testOnBorrow" value="${testOnBorrow}" />  
1.         <property name="testOnReturn" value="${testOnReturn}" />  
1.         <property name="maxOpenPreparedStatements"  
1.             value="${maxOpenPreparedStatements}" />  
1.         <property name="removeAbandoned" value="${removeAbandoned}" />   
1.         <property name="removeAbandonedTimeout" value="${removeAbandonedTimeout}" />  
1.         <property name="logAbandoned" value="${logAbandoned}" />  
1.     </bean>  
1.   
1.       
1.     <!-- jdbcTemplate -->  
1.     <bean id="jdbc" class="org.springframework.jdbc.core.JdbcTemplate">  
1.         <property name="dataSource">  
1.             <ref bean="dataSource" />  
1.         </property>  
1.     </bean>  
1.   
1.     <bean id="SpringTableOperatorBean" class="com.whyun.druid.model.TableOperator"  
1.         scope="prototype">  
1.         <property name="dataSource">  
1.             <ref bean="dataSource" />  
1.         </property>  
1.     </bean>  
1.       
1. </beans>  

**配置文件2.1**

其中第一个bean中给出的配置文件/WEB-INF/classes/dbconfig.properties就是第1节中给出的配置文件。我这里还特地给出dbcp的spring配置项，目的就是将两者进行对比，方便大家进行迁移。这里没有使用JdbcTemplate，所以jdbc那个bean没有使用到。下面给出com.whyun.druid.model.TableOperator类的代码。

**[java]** [view plain](http://blog.csdn.net/yunnysunny/article/details/8657095# "view plain")[copy](http://blog.csdn.net/yunnysunny/article/details/8657095# "copy")

1. package com.whyun.druid.model;  
1.   
1. import java.sql.Connection;  
1. import java.sql.PreparedStatement;  
1. import java.sql.SQLException;  
1. import java.sql.Statement;  
1.   
1. import javax.sql.DataSource;  
1.   
1. public class TableOperator {  
1.     private DataSource dataSource;  
1.     public void setDataSource(DataSource dataSource) {  
1.         this.dataSource = dataSource;  
1.     }  
1.   
1.     private static final int COUNT = 800;      
1.   
1.     public TableOperator() {  
1.           
1.     }  
1.   
1.     public void tearDown() throws Exception {  
1.         try {  
1.             dropTable();  
1.         } catch (SQLException e) {  
1.             e.printStackTrace();  
1.         }         
1.     }  
1.   
1.     public void insert() throws Exception {  
1.           
1.         StringBuffer ddl = new StringBuffer();  
1.         ddl.append("INSERT INTO t_big (");  
1.         for (int i = 0; i < COUNT; ++i) {  
1.             if (i != 0) {  
1.                 ddl.append(", ");  
1.             }  
1.             ddl.append("F" + i);  
1.         }  
1.         ddl.append(") VALUES (");  
1.         for (int i = 0; i < COUNT; ++i) {  
1.             if (i != 0) {  
1.                 ddl.append(", ");  
1.             }  
1.             ddl.append("?");  
1.         }  
1.         ddl.append(")");  
1.   
1.         Connection conn = dataSource.getConnection();  
1.   
1. //        System.out.println(ddl.toString());  
1.   
1.         PreparedStatement stmt = conn.prepareStatement(ddl.toString());  
1.   
1.         for (int i = 0; i < COUNT; ++i) {  
1.             stmt.setInt(i + 1, i);  
1.         }  
1.         stmt.execute();  
1.         stmt.close();  
1.   
1.         conn.close();  
1.     }  
1.   
1.     private void dropTable() throws SQLException {  
1.   
1.         Connection conn = dataSource.getConnection();  
1.   
1.         Statement stmt = conn.createStatement();  
1.         stmt.execute("DROP TABLE t_big");  
1.         stmt.close();  
1.   
1.         conn.close();  
1.     }  
1.   
1.     public void createTable() throws SQLException {  
1.         StringBuffer ddl = new StringBuffer();  
1.         ddl.append("CREATE TABLE t_big (FID INT AUTO_INCREMENT PRIMARY KEY ");  
1.         for (int i = 0; i < COUNT; ++i) {  
1.             ddl.append(", ");  
1.             ddl.append("F" + i);  
1.             ddl.append(" BIGINT NULL");  
1.         }  
1.         ddl.append(")");  
1.   
1.         Connection conn = dataSource.getConnection();  
1.   
1.         Statement stmt = conn.createStatement();  
1.         stmt.execute(ddl.toString());  
1.         stmt.close();  
1.   
1.         conn.close();  
1.     }  
1. }  

**代码片段2.1**

**注意：在使用的时候，通过获取完Connection对象，在使用完之后，要将其close掉，这样其实是将用完的连接放入到连接池中，如果你不close的话，会造成连接泄露。**
然后我们写一个servlet来测试他.

**[java]** [view plain](http://blog.csdn.net/yunnysunny/article/details/8657095# "view plain")[copy](http://blog.csdn.net/yunnysunny/article/details/8657095# "copy")

1. package com.whyun.druid.servelt;  
1.   
1. import java.io.IOException;  
1. import java.io.PrintWriter;  
1. import java.sql.SQLException;  
1.   
1. import javax.servlet.ServletContext;  
1. import javax.servlet.ServletException;  
1. import javax.servlet.http.HttpServlet;  
1. import javax.servlet.http.HttpServletRequest;  
1. import javax.servlet.http.HttpServletResponse;  
1.   
1. import org.springframework.web.context.WebApplicationContext;  
1. import org.springframework.web.context.support.WebApplicationContextUtils;  
1.   
1. import com.whyun.druid.model.TableOperator;  
1.   
1. public class TestServlet extends HttpServlet {  
1.     private TableOperator operator;  
1.       
1.   
1.     @Override  
1.     public void init() throws ServletException {  
1.           
1.         super.init();  
1.          ServletContext servletContext = this.getServletContext();     
1.            
1.          WebApplicationContext ctx  
1.             = WebApplicationContextUtils.getWebApplicationContext(servletContext);  
1.          operator = (TableOperator)ctx.getBean("SpringTableOperatorBean");  
1.     }  
1.   
1.     /** 
1.      * The doGet method of the servlet. <br> 
1.      * 
1.      * This method is called when a form has its tag value method equals to get. 
1.      *  
1.      * @param request the request send by the client to the server 
1.      * @param response the response send by the server to the client 
1.      * @throws ServletException if an error occurred 
1.      * @throws IOException if an error occurred 
1.      */  
1.     public void doGet(HttpServletRequest request, HttpServletResponse response)  
1.             throws ServletException, IOException {  
1.   
1.         response.setContentType("text/html");  
1.         PrintWriter out = response.getWriter();  
1.   
1.         boolean createResult = false;  
1.         boolean insertResult = false;  
1.         boolean dropResult = false;  
1.           
1.         try {  
1.             operator.createTable();  
1.             createResult = true;  
1.         } catch (SQLException e) {  
1.             e.printStackTrace();  
1.         }  
1.         if (createResult) {  
1.             try {  
1.                 operator.insert();  
1.                 insertResult = true;  
1.             } catch (Exception e) {  
1.                 e.printStackTrace();  
1.             }  
1.             try {  
1.                 operator.tearDown();  
1.                 dropResult = true;  
1.             } catch (Exception e) {  
1.                 e.printStackTrace();  
1.             }  
1.         }  
1.           
1.           
1.         out.println("{'createResult':"+createResult+",'insertResult':"  
1.                 +insertResult+",'dropResult':"+dropResult+"}");  
1.           
1.         out.flush();  
1.         out.close();  
1.     }  
1.   
1. }  
**代码片段2.2**

这里没有用到struts2或者springmvc，虽然大部分开发者用的是这两种框架。

### []()2.2 不使用spring

类似于dbcp，druid也提供了原生态的支持。先看下面这段代码：

**[java]** [view plain](http://blog.csdn.net/yunnysunny/article/details/8657095# "view plain")[copy](http://blog.csdn.net/yunnysunny/article/details/8657095# "copy")

1. package com.whyun.util.db;  
1.   
1. import javax.sql.DataSource;  
1.   
1. import org.apache.commons.dbcp.BasicDataSourceFactory;  
1.   
1. import com.alibaba.druid.pool.DruidDataSourceFactory;  
1. import com.whyun.util.config.MySqlConfigProperty;  
1. import com.whyun.util.config.MySqlConfigProperty2;  
1.   
1. /** 
1.  * The Class DataSourceUtil. 
1.  */  
1. public class DataSourceUtil {  
1.       
1.     /** 使用配置文件dbconfig.properties构建Druid数据源. */  
1.     public static final int DRUID_MYSQL_SOURCE = 0;  
1.       
1.     /** 使用配置文件dbconfig2.properties构建Druid数据源. */  
1.     public static final int DRUID_MYSQL_SOURCE2 = 1;  
1.       
1.     /** 使用配置文件dbconfig.properties构建Dbcp数据源. */  
1.     public static final int DBCP_SOURCE = 4;  
1.       
1.     /** 
1.      * 根据类型获取数据源 
1.      * 
1.      * @param sourceType 数据源类型 
1.      * @return druid或者dbcp数据源 
1.      * @throws Exception the exception 
1.      */  
1.     public static final DataSource getDataSource(int sourceType)  
1.         throws Exception {  
1.         DataSource dataSource = null;  
1.         switch(sourceType) {  
1.         case DRUID_MYSQL_SOURCE:              
1.             dataSource = DruidDataSourceFactory.createDataSource(  
1.                     MySqlConfigProperty.getInstance().getProperties());               
1.             break;  
1.         case DRUID_MYSQL_SOURCE2:  
1.             dataSource = DruidDataSourceFactory.createDataSource(  
1.                     MySqlConfigProperty2.getInstance().getProperties());  
1.             break;  
1.         case DBCP_SOURCE:  
1.             dataSource = BasicDataSourceFactory.createDataSource(  
1.                     MySqlConfigProperty.getInstance().getProperties());  
1.             break;  
1.         }  
1.         return dataSource;  
1.     }  
1. }  

**代码片段2.3 手动读取配置文件初始化连接池**

第37行中调用了类com.alibaba.druid.pool.DruidDataSourceFactory中createDataSource方法来初始化一个连接池。对比dbcp的使用方法，两者很相似。

下面给出一个多线程的测试程序。运行后可以比较druid和dbcp的性能差别。

**[java]** [view plain](http://blog.csdn.net/yunnysunny/article/details/8657095# "view plain")[copy](http://blog.csdn.net/yunnysunny/article/details/8657095# "copy")

1. package com.whyun.druid.test;  
1.   
1. import java.sql.SQLException;  
1. import java.util.ArrayList;  
1. import java.util.List;  
1. import java.util.concurrent.Callable;  
1. import java.util.concurrent.ExecutorService;  
1. import java.util.concurrent.Executors;  
1. import java.util.concurrent.Future;  
1. import java.util.concurrent.TimeUnit;  
1.   
1. import com.whyun.druid.model.TableOperator;  
1. import com.whyun.util.db.DataSourceUtil;  
1.   
1. public class MutilThreadTest {  
1.     public static void test(int dbType, int times)  
1.         throws Exception {   
1.         int numOfThreads =Runtime.getRuntime().availableProcessors()*2;  
1.         ExecutorService executor = Executors.newFixedThreadPool(numOfThreads);    
1.         final TableOperator test = new TableOperator();  
1. //        int dbType = DataSourceUtil.DRUID_MYSQL_SOURCE;  
1. //        dbType = DataSourceUtil.DBCP_SOURCE;  
1.         test.setDataSource(DataSourceUtil.getDataSource(dbType));  
1.           
1.         boolean createResult = false;  
1.         try {  
1.             test.createTable();  
1.             createResult = true;  
1.         } catch (SQLException e) {  
1.             e.printStackTrace();  
1.         }  
1.         if (createResult) {  
1.             List<Future<Long>> results = new ArrayList<Future<Long>>();     
1.             for (int i = 0; i < times; i++) {    
1.                 results.add(executor.submit(new Callable<Long>() {    
1.                     @Override    
1.                     public Long call() throws Exception {    
1.                             long begin = System.currentTimeMillis();  
1.                                 try {  
1.                                     test.insert();  
1.                                     //insertResult = true;  
1.                                 } catch (Exception e) {  
1.                                     e.printStackTrace();  
1.                                 }                             
1.                             long end = System.currentTimeMillis();    
1.                         return end - begin;    
1.                     }    
1.                 }));    
1.             }    
1.             executor.shutdown();    
1.             while(!executor.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS));    
1.                 
1.             long sum = 0;    
1.             for (Future<Long> result : results) {    
1.                 sum += result.get();    
1.             }    
1.                 
1.                 
1.             System.out.println("---------------db type "+dbType+"------------------");    
1.             System.out.println("number of threads :" + numOfThreads + " times:" + times);    
1.             System.out.println("running time: " + sum + "ms");    
1.             System.out.println("TPS: " + (double)(100000 * 1000) / (double)(sum));    
1.             System.out.println();    
1.             try {  
1.                 test.tearDown();  
1.                 //dropResult = true;  
1.             } catch (Exception e) {  
1.                 e.printStackTrace();  
1.             }  
1.         } else {  
1.             System.out.println("初始化数据库失败");  
1.         }  
1.           
1.     }    
1.       
1.     public static void main (String argc[])  
1.         throws Exception {  
1.         test(DataSourceUtil.DBCP_SOURCE,50);  
1.         test(DataSourceUtil.DRUID_MYSQL_SOURCE,50);  
1.           
1.     }  
1. }  

**代码片段2.4 连接池多线程测试程序**

****

## []()**3 监控**

### []()**3.1 web监控**

druid提供了sql语句查询时间等信息的监控功能。为了让数据库查询一直运行，下面特地写了一个ajax进行轮询。同时，还要保证在web.xml中配置如下信息

**[html]** [view plain](http://blog.csdn.net/yunnysunny/article/details/8657095# "view plain")[copy](http://blog.csdn.net/yunnysunny/article/details/8657095# "copy")

1. <servlet>  
1.         <servlet-name>DruidStatView</servlet-name>  
1.         <servlet-class>com.alibaba.druid.support.http.StatViewServlet</servlet-class>  
1.     </servlet>  
1. <servlet-mapping>  
1.         <servlet-name>DruidStatView</servlet-name>  
1.         <url-pattern>/druid/*</url-pattern>  
1.     </servlet-mapping>  
**配置文件3.1 在web.xml中添加druid监控**

****同时将ajax代码提供如下

**[javascript]** [view plain](http://blog.csdn.net/yunnysunny/article/details/8657095# "view plain")[copy](http://blog.csdn.net/yunnysunny/article/details/8657095# "copy")

1. function showTime() {  
1.     var myDate = new Date();  
1.     var timeStr = '';  
1.     timeStr += myDate.getFullYear()+'-'; //获取完整的年份(4位,1970-????)  
1.     timeStr += myDate.getMonth()+'-';      //获取当前月份(0-11,0代表1月)  
1.     timeStr += myDate.getDate() + ' ';      //获取当前日(1-31)  
1.     timeStr += myDate.getHours()+':';      //获取当前小时数(0-23)  
1.     timeStr += myDate.getMinutes()+':';    //获取当前分钟数(0-59)  
1.     timeStr += myDate.getSeconds();    //获取当前秒数(0-59)  
1.     return timeStr  
1. }  
1. $(document).ready(function() {  
1.     function loadDBTestMessage() {  
1.         $.get('servlet/MysqlTestServlet',function(data) {  
1.             if (typeof(data) != 'object') {  
1.                 data = eval('(' + data + ')');  
1.             }  
1.             var html = '['+showTime()+']';  
1.             html += '创建：' + data['createResult'];  
1.             html +=  '插入：' + data['insertResult'];  
1.             html += '销毁:' + data['dropResult'];  
1.             html +=   
1.             $('#message').html(html);  
1.         });  
1.     }  
1.       
1.     setInterval(function() {  
1.         loadDBTestMessage();  
1.     }, 10000);  
1. });  
**代码片段3.1 ajax轮询**

这时打开http://localhost/druid-web/druid/ 地址，会看到监控界面，点击其中的sql标签。

![]()

**图3.1 监控界面查看sql查询时间**

**注意：在写配置文件1.1时，要保证filter配置项中含有stat属性，否则这个地方看不到sql语句的监控数据。**

表格中各项含义如下

****
名称
 
解释
 
备注 ExecuteCount
 
当前sql已执行次数 ExecTime
 
当前sql已执行时间 ExecMax
 
当前sql最大执行时间 Txn
 
当前运行的事务数量 Error
 
当前sql执行出错的数目 Update
 
当前sql更新或者删除操作中已经影响的行数 FetchRow
 
当前sql操作中已经读取的行数 Running
 
当前sql正在运行的数目 Concurrent
 
当前sql最大并发执行数  ExecHisto 
 
当前sql做execute操作的时间分布数组
 
分为0-1,1-10,10-100,100-1000，>1000，5个时间分布区域，单位为ms ExecRsHisto 
 
当前sql做execute操作和resultSet

打开至关闭的时间总和分布数组
 
同上 FetchRowHisto
 
当前sql查询时间分布数组
 
同上 UpdateHisto 
 
当前sql更新、删除时间分布数组
 
同上表3.1 监控字段含义

老版本的druid的jar包中不支持通过web界面进行远程监控，从0.2.14开始可以通过配置jmx地址来获取远程运行druid的服务器的监控信息。具体配置方法如下：

**[html]** [view plain](http://blog.csdn.net/yunnysunny/article/details/8657095# "view plain")[copy](http://blog.csdn.net/yunnysunny/article/details/8657095# "copy")

1. <servlet>  
1.         <servlet-name>DruidStatView</servlet-name>  
1.         <servlet-class>com.alibaba.druid.support.http.StatViewServlet</servlet-class>  
1.         <init-param>  
1.             <param-name>jmxUrl</param-name>  
1.             <param-value>service:jmx:rmi:///jndi/rmi://localhost:9004/jmxrmi</param-value>  
1.         </init-param>  
1.     </servlet>  
1.     <servlet-mapping>  
1.         <servlet-name>DruidStatView</servlet-name>  
1.         <url-pattern>/druid/*</url-pattern>  
1.     </servlet-mapping>  
配置文件3.2 远程监控web

这里连接的配置参数中多了一个jmxUrl，里面配置一个jmx连接地址。jmx连接中也可以指定用户名、密码，在上面的servlet中添加两个init-param，其param-name分别为jmxUsername和jmxPassword，分别对应连接jmx的用户名和密码。对于jmx在服务器端的配置，可以参考3.2节中的介绍。

### []()**3.2 jconsole监控**

同时druid提供了jconsole监控的功能，因为界面做的不是很好，所以官方中没有对其的相关介绍。如果是纯java程序的话，上面提到的web监控就无法使用了，jconsole的作用就体现出来了。不过我在下面做教程的时候，依然使用的是刚才用的web项目。

首先在catalina.bat（或者catalina.sh）中加入java的启动选项，放置于if "%OS%" == "Windows_NT" setlocal这句之后。

set JAVA_OPTS=%JAVA_OPTS% -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port="9004" -Dcom.sun.management.jmxremote.authenticate="false" -Dcom.sun.management.jmxremote.ssl="false"

保存完之后，启动startup.bat(或者startup.sh)来运行tomcat（上面设置java启动项的配置，按理来说在eclipse中也能适用，但是笔者在其下没有试验成功）。然后在远程的某台电脑的命令行中运行如下命令

jconsole -pluginpath E:\kuaipan\workspace6\druid-web\WebRoot\WEB-INF\lib\druid-0.2.11.jar

这里的最后一个参数就是你的druid的jar包的路径。

![]()

**图3.2 jconsole连接界面**

在远程进程的输入框里面输入ip:端口号，然后点击连接（上面的配置中没有指定用户名、密码，所以这里不用填写）。打开的界面如下：

![]()

**图3.3 jconsole 连接成功界面**

可以看到和web监控界面类似的数据了。
来源： <[http://blog.csdn.net/yunnysunny/article/details/8657095](http://blog.csdn.net/yunnysunny/article/details/8657095)> 
